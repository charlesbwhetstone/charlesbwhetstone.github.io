---
permalink: /pizza-game/
title: "⚡ Electric Crust Pizza Delivery Game"
layout: none
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⚡ Electric Crust Pizza Delivery - Charles Whetstone</title>
    
    <!-- GitHub API Configuration for Automatic Leaderboard Updates -->
    <script>
      // GitHub API configuration for automatic leaderboard updates
      window.GITHUB_CONFIG = {
        // IMPORTANT: To enable automatic updates, you need to add your GitHub Personal Access Token
        // Get one at: https://github.com/settings/tokens (requires 'repo' scope for your repository)
        // Leave empty for local-only mode, or add your token here for automatic global updates
        token: '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', // Replace this with your actual token
        
        // Repository details (safe to keep public)
        owner: 'charlesbwhetstone',
        repo: 'charlesbwhetstone.github.io',
        path: 'assets/pizza-game-scores.json',
        branch: 'main'
      };
    </script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0a1f 0%, #1a1a3f 50%, #2d1a4a 100%);
            font-family: 'Courier New', monospace;
            color: white;
            overflow-x: hidden;
        }
        
        .game-header {
            text-align: center;
            padding: 20px;
            background: rgba(0,0,0,0.8);
            border-bottom: 3px solid #ffdd00;
        }
        
        .game-title {
            color: #ffdd00;
            font-size: 36px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 0 15px rgba(255,221,0,0.7);
        }
        
        .game-subtitle {
            color: #00ff88;
            font-size: 18px;
            margin: 5px 0 0 0;
        }
        
        .navigation {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
        }
        
        .nav-link {
            color: #00ff88;
            text-decoration: none;
            font-size: 16px;
            font-weight: bold;
            padding: 8px 16px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #00ff88;
            border-radius: 25px;
            transition: all 0.3s;
        }
        
        .nav-link:hover {
            background: rgba(0,255,136,0.2);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,255,136,0.3);
        }
        
        .game-container {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            gap: 20px;
            align-items: flex-start;
        }
        
        .game-main {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            border: 2px solid #ffdd00;
            overflow: visible;
        }
        
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.5);
            border-bottom: 2px solid #ffdd00;
        }
        
        .game-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: 2px solid #ffdd00;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
        }
        
        .game-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255,221,0,0.4);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }
        
        .game-wrapper {
            display: flex;
            justify-content: center;
            padding: 20px;
            position: relative;
        }
        
        #gameCanvas {
            border: 3px solid #ffdd00;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255,221,0,0.3);
            background: #000;
        }
        
        /* High Score System Styles */
        .high-score-sidebar {
            width: 280px;
            min-width: 280px;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            border: 3px solid #ffdd00;
            height: fit-content;
        }

        .high-score-header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 3px solid #ffdd00;
            padding-bottom: 15px;
        }

        .high-score-header h3 {
            color: #ffdd00;
            font-family: 'Courier New', monospace;
            font-size: 22px;
            margin: 0;
            text-shadow: 0 0 15px rgba(255,221,0,0.7);
        }

        .high-score-list {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            line-height: 1.5;
        }

        .high-score-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            margin: 4px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            color: #ecf0f1;
            transition: all 0.3s;
        }

        .high-score-entry:hover {
            background: rgba(255,221,0,0.2);
            transform: translateX(5px);
        }

        .high-score-entry.new-score {
            background: linear-gradient(90deg, #ffdd00, #ff8800);
            color: #000;
            animation: flashScore 1s ease-in-out 3;
        }

        @keyframes flashScore {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .high-score-rank {
            font-weight: bold;
            color: #ffdd00;
            min-width: 30px;
        }

        .high-score-initials {
            font-weight: bold;
            color: #00ff88;
            font-size: 18px;
        }

        .high-score-score {
            font-weight: bold;
            color: #ff6b6b;
        }
        
        .instructions {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid #00ff88;
        }
        
        .instructions h3 {
            color: #ffdd00;
            margin-top: 0;
            font-size: 20px;
        }
        
        .instructions p {
            color: #ecf0f1;
            line-height: 1.6;
            margin: 8px 0;
        }
        
        .control-section {
            background: rgba(255,221,0,0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .control-section h4 {
            color: #ffdd00;
            margin: 0 0 10px 0;
            font-size: 18px;
        }
        
        /* Responsive Design */
        @media (max-width: 1200px) and (min-width: 769px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .high-score-sidebar {
                width: 100%;
                max-width: 900px;
                order: 2;
            }
            
            .game-main {
                order: 1;
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            body {
                overflow-x: hidden;
                overflow-y: auto;
            }
            
            .game-title {
                font-size: 20px;
                line-height: 1.2;
            }
            
            .game-subtitle {
                font-size: 12px;
                line-height: 1.3;
            }
            
            .game-header {
                padding: 8px;
                min-height: auto;
            }
            
            .game-container {
                padding: 5px;
                flex-direction: column;
                min-height: calc(100vh - 120px);
                overflow-y: auto;
                overflow-x: hidden;
            }
            
            .game-main {
                order: 1;
                flex: 1;
                min-height: 400px;
                width: 100%;
            }
            
            .game-controls {
                flex-wrap: wrap;
                padding: 8px;
                gap: 8px;
                justify-content: center;
                overflow: visible;
                min-height: 50px;
            }
            
            .game-btn {
                padding: 8px 12px;
                font-size: 12px;
                white-space: nowrap;
            }
            
            /* Hide high score sidebar on mobile for full-screen gaming */
            .high-score-sidebar {
                display: none;
            }
            
            .game-wrapper {
                padding: 5px;
                min-height: 300px;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
            }
            
            #gameCanvas {
                max-width: calc(100vw - 20px);
                max-height: 400px;
                width: auto;
                height: auto;
                object-fit: contain;
            }
            
            .navigation {
                position: relative;
                text-align: center;
                margin-bottom: 5px;
            }
            
            /* Mobile touch controls - force show */
            #mobileControls {
                display: block !important;
                pointer-events: none !important;
                position: absolute !important;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 1000;
            }
            
            #virtualJoystick, #fireButton, #autoFireButton {
                pointer-events: auto !important;
                user-select: none;
                -webkit-user-select: none;
                -webkit-touch-callout: none;
                -webkit-tap-highlight-color: transparent;
                position: absolute !important;
            }
            
            #virtualJoystick {
                bottom: 20px !important;
                left: 20px !important;
                width: 120px !important;
                height: 120px !important;
                background: rgba(255,255,255,0.2) !important;
                border: 3px solid rgba(255,255,255,0.5) !important;
                border-radius: 50% !important;
                z-index: 1001 !important;
            }
            
            #fireButton {
                bottom: 20px !important;
                right: 20px !important;
                width: 90px !important;
                height: 90px !important;
                background: rgba(255,0,0,0.7) !important;
                border: 3px solid rgba(255,0,0,0.9) !important;
                border-radius: 50% !important;
                z-index: 1001 !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                color: white !important;
                font-weight: bold !important;
                font-size: 16px !important;
            }
            
            #autoFireButton {
                bottom: 170px !important;
                right: 20px !important;
                width: 60px !important;
                height: 60px !important;
                background: rgba(255,221,0,0.7) !important;
                border: 3px solid rgba(255,221,0,0.9) !important;
                border-radius: 50% !important;
                z-index: 1001 !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                color: white !important;
                font-size: 12px !important;
                font-weight: bold !important;
            }
            
            #virtualJoystick:active, #fireButton:active, #autoFireButton:active {
                transform: scale(0.95);
            }
        }
        
        /* Portrait mode - optimized for phone aspect ratio */
        @media (max-width: 768px) and (orientation: portrait) {
            .game-container {
                min-height: calc(100vh - 100px);
                overflow-y: auto;
            }
            
            #gameCanvas {
                max-height: 220px;
                max-width: calc(100vw - 20px);
                width: auto;
                height: auto;
            }
        }
        
        /* Landscape mode - keep high scores hidden */
        @media (max-width: 768px) and (orientation: landscape) {
            html {
                height: auto !important;
                overflow: visible !important;
            }
            
            body {
                height: auto !important;
                min-height: auto !important;
                max-height: none !important;
                overflow-y: scroll !important;
                overflow-x: hidden !important;
                touch-action: manipulation !important;
                -webkit-overflow-scrolling: touch !important;
            }
            
            .game-header {
                padding: 2px;
                text-align: center;
            }
            
            .game-title {
                font-size: 12px !important;
                margin: 1px 0 !important;
                line-height: 1.1;
            }
            
            .game-subtitle {
                font-size: 8px !important;
                margin: 1px 0 !important;
                line-height: 1.0;
            }
            
            .game-container {
                display: flex !important;
                flex-direction: column !important;
                width: 100% !important;
                height: auto !important;
                min-height: auto !important;
                max-height: none !important;
                overflow: visible !important;
                padding: 10px !important;
                margin: 0 !important;
                box-sizing: border-box !important;
            }
            
            .game-main {
                order: 1 !important;
                width: 100% !important;
                flex: 1 !important;
                margin: 0 !important;
                padding: 5px !important;
                overflow: visible !important;
                border-radius: 8px !important;
            }
            
            /* Completely remove high score sidebar in landscape */
            .high-score-sidebar {
                display: none !important;
                visibility: hidden !important;
                width: 0 !important;
                height: 0 !important;
                margin: 0 !important;
                padding: 0 !important;
                order: 999 !important;
            }
            
            .game-wrapper {
                min-height: auto !important;
                height: auto !important;
                width: 100% !important;
                margin: 0 auto !important;
                padding: 5px !important;
                overflow: visible !important;
                max-width: 500px !important;
                position: relative !important;
            }
            
            /* Add space below for scrolling */
            .game-container::after {
                content: '';
                display: block;
                height: 150px;
                width: 100%;
            }
            
            #gameCanvas {
                height: 180px !important;
                width: calc(100vw - 20px) !important;
                max-width: 320px !important;
                max-height: 180px !important;
                margin: 5px auto !important;
                display: block !important;
                border: 2px solid #ffdd00 !important;
                background: #000 !important;
            }
            
            /* Mobile controls positioning for landscape - overlay on canvas area */
            #mobileControls {
                position: absolute !important;
                bottom: 5px !important;
                left: 0 !important;
                right: 0 !important;
                z-index: 1000 !important;
                pointer-events: none !important;
                height: 50px !important;
                margin-top: 0 !important;
                display: flex !important;
                justify-content: space-between !important;
                align-items: center !important;
                padding: 0 10px !important;
            }
            
            .game-wrapper {
                position: relative !important;
            }
            
            #virtualJoystick {
                position: absolute !important;
                bottom: 80px !important;
                left: 20px !important;
                pointer-events: auto !important;
                z-index: 1001 !important;
                width: 80px !important;
                height: 80px !important;
                margin: 0 !important;
                opacity: 0.9 !important;
            }
            
            #fireButton {
                position: absolute !important;
                bottom: 80px !important;
                right: 20px !important;
                pointer-events: auto !important;
                z-index: 1001 !important;
                width: 70px !important;
                height: 70px !important;
                margin: 0 !important;
                opacity: 0.9 !important;
            }
        }
        
        /* Extreme mobile landscape override - highest specificity */
        @media screen and (max-width: 896px) and (orientation: landscape) {
            html {
                overflow: visible !important;
                height: auto !important;
            }
            
            body.game-page {
                overflow-y: scroll !important;
                height: auto !important;
                min-height: auto !important;
                max-height: none !important;
                position: relative !important;
            }
            
            .game-container {
                display: flex !important;
                flex-direction: column !important;
                flex-wrap: nowrap !important;
                height: auto !important;
                min-height: auto !important;
                max-height: none !important;
                overflow: visible !important;
            }
            
            /* AGGRESSIVE HIGH SCORE SIDEBAR HIDING */
            .high-score-sidebar,
            #highScoreSection,
            .high-score-section,
            [class*="high-score"] {
                display: none !important;
                visibility: hidden !important;
                position: absolute !important;
                left: -9999px !important;
                top: -9999px !important;
                width: 0 !important;
                height: 0 !important;
                max-width: 0 !important;
                max-height: 0 !important;
                overflow: hidden !important;
                opacity: 0 !important;
                pointer-events: none !important;
                z-index: -1 !important;
            }
            
            /* Force single column layout */
            .game-main {
                width: 100% !important;
                max-width: 100% !important;
                flex: 1 !important;
                order: 1 !important;
            }
            
            /* Ensure content can scroll past viewport */
            .game-wrapper {
                margin-bottom: 100px !important;
                width: 100% !important;
                max-width: 100% !important;
            }
        }
        
        /* Mobile Portrait Mode Optimizations */
        @media (max-width: 480px) and (orientation: portrait) {
            .game-wrapper {
                padding: 5px;
            }
            
            #gameCanvas {
                width: 100%;
                max-width: 100vw;
                height: auto;
                max-height: 50vh;
            }
            
            .game-container {
                padding: 5px;
                gap: 10px;
            }
            
            .high-score-sidebar {
                padding: 10px;
                font-size: 12px;
            }
            
            .high-score-entry {
                font-size: 12px;
                padding: 4px 8px;
            }
            
            .instructions {
                padding: 10px;
                margin: 10px 0;
            }
            
            .instructions h3 {
                font-size: 16px;
            }
            
            .instructions p {
                font-size: 12px;
            }
        }
        
        /* Mobile Landscape Mode Optimizations */
        @media (max-height: 500px) and (orientation: landscape) {
            body {
                overflow-y: auto;
            }
            
            .game-header {
                padding: 10px;
            }
            
            .game-title {
                font-size: 24px;
            }
            
            .game-subtitle {
                font-size: 14px;
            }
            
            .game-container {
                flex-direction: row;
                padding: 5px;
                gap: 10px;
                max-height: calc(100vh - 120px);
                overflow-y: auto;
            }
            
            .game-main {
                flex: 1;
                min-width: 0;
            }
            
            .high-score-sidebar {
                width: 250px;
                max-height: 400px;
                overflow-y: auto;
                order: 2;
            }
            
            #gameCanvas {
                max-width: 100%;
                max-height: 350px;
                width: auto;
                height: auto;
            }
            
            .game-wrapper {
                padding: 5px;
            }
        }
        
        /* Ensure game controls are visible on very small screens */
        @media (max-height: 600px) {
            .game-controls {
                padding: 5px !important;
                gap: 5px !important;
                flex-wrap: wrap !important;
                justify-content: center !important;
            }
            
            .game-btn {
                padding: 6px 10px !important;
                font-size: 12px !important;
                min-width: auto !important;
            }
        }
        
        @media (max-width: 480px) {
            .game-controls {
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .game-btn {
                padding: 10px 15px;
                font-size: 14px;
            }
            
            /* Ensure mobile controls always show on small screens */
            #mobileControls {
                display: block !important;
            }
        }
        
        /* iPad and larger tablet specific adjustments */
        @media (min-width: 769px) and (max-width: 1024px) {
            #virtualJoystick {
                bottom: 40px !important;
                left: 30px !important;
                width: 100px !important;
                height: 100px !important;
            }
            
            #fireButton {
                bottom: 40px !important;
                right: 30px !important;
                width: 80px !important;
                height: 80px !important;
                font-size: 14px !important;
            }
            
            #autoFireButton {
                bottom: 140px !important;
                right: 30px !important;
                width: 60px !important;
                height: 60px !important;
                font-size: 10px !important;
            }
        }
        
        /* Large iPad Pro and similar devices */
        @media (min-width: 1025px) and (max-width: 1366px) {
            #virtualJoystick {
                bottom: 60px !important;
                left: 50px !important;
                width: 110px !important;
                height: 110px !important;
            }
            
            #fireButton {
                bottom: 60px !important;
                right: 50px !important;
                width: 85px !important;
                height: 85px !important;
                font-size: 15px !important;
            }
            
            #autoFireButton {
                bottom: 160px !important;
                right: 50px !important;
                width: 65px !important;
                height: 65px !important;
                font-size: 11px !important;
            }
        }
    </style>
</head>
<body class="game-page">
    <div class="navigation">
        <a href="/" class="nav-link">← Back to Portfolio</a>
    </div>
    
    <div class="game-header">
        <h1 class="game-title">⚡ ELECTRIC CRUST PIZZA DELIVERY 🍕</h1>
        <p class="game-subtitle">Navigate through space and deliver delicious pizzas while avoiding hostile forces!</p>
    </div>
    
    <div class="game-container">
        <div class="game-main">
            <div class="game-controls">
                <button onclick="toggleGamePause()" class="game-btn" id="pauseBtn">⏸️ Pause</button>
                <button onclick="restartGame()" class="game-btn">🔄 Restart</button>
                <a href="#" class="game-btn" onclick="toggleFullScreen()" title="Toggle Fullscreen">🖥️ Fullscreen</a>
            </div>
            
            <div class="game-wrapper">
                <canvas id="gameCanvas" width="800" height="450"></canvas>
                
                <!-- MOBILE TOUCH CONTROLS -->
                <div id="mobileControls" style="display:none; position:absolute; top:0; left:0; width:100%; max-width:800px; height:450px; pointer-events:none; z-index:10;">
                    <!-- Virtual Joystick -->
                    <div id="virtualJoystick" style="position:absolute; bottom:80px; left:20px; width:120px; height:120px; background:rgba(255,255,255,0.15); border:3px solid rgba(255,255,255,0.4); border-radius:50%; z-index:11; touch-action:none; user-select:none; pointer-events:auto;">
                        <div id="joystickKnob" style="position:absolute; width:45px; height:45px; background:rgba(0,255,136,0.8); border:2px solid rgba(0,255,136,1); border-radius:50%; left:50%; top:50%; transform:translate(-50%,-50%); transition:all 0.1s; box-shadow:0 3px 10px rgba(0,0,0,0.4);"></div>
                    </div>
                    
                    <div id="fireButton" style="position:absolute; bottom:80px; right:20px; width:90px; height:90px; background:rgba(255,0,0,0.6); border:3px solid rgba(255,0,0,0.8); border-radius:50%; z-index:11; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold; font-size:16px; touch-action:none; user-select:none; box-shadow:0 3px 10px rgba(0,0,0,0.4); transition:all 0.1s; pointer-events:auto;">FIRE</div>
                    
                    <div id="autoFireButton" style="position:absolute; bottom:190px; right:20px; width:70px; height:70px; background:rgba(255,221,0,0.6); border:3px solid rgba(255,221,0,0.8); border-radius:50%; z-index:11; display:flex; align-items:center; justify-content:center; color:white; font-size:12px; font-weight:bold; touch-action:none; user-select:none; box-shadow:0 3px 10px rgba(0,0,0,0.4); transition:all 0.1s; pointer-events:auto;">AUTO</div>
                </div>
            </div>
        </div>
        
        <!-- High Score Sidebar -->
        <div class="high-score-sidebar">
            <div class="high-score-header">
                <h3>🏆 HIGH SCORES</h3>
            </div>
            <div id="highScoreList" class="high-score-list">
                <!-- High scores will be populated by JavaScript -->
            </div>
            
            <div class="instructions">
                <h3>🎮 Game Controls</h3>
                <div class="control-section">
                    <h4>🚀 Movement</h4>
                    <p><strong>Arrow Keys</strong> or <strong>WASD</strong>: Navigate your electric vehicle</p>
                </div>
                <div class="control-section">
                    <h4>💥 Combat</h4>
                    <p><strong>SPACE</strong>: Fire energy blasts</p>
                </div>
                <div class="control-section">
                    <h4>🎯 Objective</h4>
                    <p>Collect 🍕 pizzas (+20 pts)<br>
                    Destroy enemies (+10 pts)<br>
                    Collect power-ups for bonuses!</p>
                </div>
            </div>
        </div>
    </div>

    <script>
// Electric Crust Pizza Delivery Game - Enhanced Version
class ElectricCrustPizzaGame {
  constructor(canvasId) {
    this.canvas = document.getElementById(canvasId);
    if (!this.canvas) {
      console.error('Canvas element not found!');
      return;
    }
    
    this.ctx = this.canvas.getContext('2d');
    if (!this.ctx) {
      console.error('Could not get 2D context!');
      return;
    }
    
    // Set canvas dimensions explicitly for mobile-friendly 16:9 aspect ratio
    this.canvas.width = 800;
    this.canvas.height = 450;
    
    console.log(`Canvas initialized: ${this.canvas.width}x${this.canvas.height}`);
    
    // Initialize Audio System
    this.initAudioSystem();
    
    // Game state
    this.gameRunning = false;
    this.paused = false;
    this.showGameOverScreen = false;
    this.gameOverTimer = 0;
    this.score = 0;
    this.level = 1;
    this.speed = 2;
    this.lastLevelUpAt = 0; // Track last enemy count when level up occurred
    this.completedMilestones = new Set(); // Track which level-up milestones have been reached
    
    // Debug mode for collision visualization (toggle with 'D' key)
    this.debugMode = false;
    this.hyperBoostMode = false; // Track hyper boost travel mode
    
    // High Score System
    this.showInitialEntry = false;
    this.initialEntry = { initials: '', currentChar: 0 };
    this.highScores = [
      { initials: 'CWH', score: 15000, date: '2025-09-14' },
      { initials: 'AAA', score: 12500, date: '2025-09-14' },
      { initials: 'BBB', score: 10000, date: '2025-09-14' }
    ]; // Default scores, will be replaced when loading completes
    this.pendingHighScore = null; // Store high score that needs to be added to repo
    
    // Load high scores asynchronously and replace defaults
    this.loadHighScores().then(scores => {
      this.highScores = scores;
      this.updateHighScoreDisplay();
      console.log('📚 High scores loaded and updated');
    }).catch(error => {
      console.warn('📚 Failed to load high scores, using defaults:', error);
    });
    
    // Score popup effects system
    this.scorePopups = [];
    this.levelUpEffect = null;
    this.enemiesDestroyed = 0;
    
    // Power-up system
    this.activePowerUps = new Map(); // Track active power-ups and their timers
    this.lastUpdateTime = null; // For accurate timer calculations
    this.powerUpEffects = []; // Visual effects for power-ups
    
    // Player (rocket ship)
    this.player = {
      x: 80,
      y: 300,
      width: 100,
      height: 100,
      health: 3,
      maxHealth: 3,
      speed: 5,
      moving: false
    };
    
    // Game objects arrays
    this.bullets = [];
    this.enemies = [];
    this.pizzas = [];
    this.powerups = [];
    this.particles = [];
    this.soundEffects = [];
    this.stars = [];
    
    // Input handling
    this.keys = {};
    
    // Initialize stars for background
    this.initStars();
    this.setupEventListeners();
    
    // Initialize screen shake
    this.screenShake = 0;
    
    // Track actual user touch interaction
    this.userHasTouched = false;
    
    this.startGame();
  }
  
  initStars() {
    // Reduce star count on mobile devices for better performance
    const starCount = this.isMobileDevice ? 40 : 80;
    for (let i = 0; i < starCount; i++) {
      this.stars.push({
        x: Math.random() * this.canvas.width,
        y: Math.random() * this.canvas.height,
        size: Math.random() * 3 + 0.5,
        speed: Math.random() * 0.8 + 0.2,
        twinkle: Math.random() * Math.PI * 2, // For twinkling effect
        brightness: Math.random() * 0.7 + 0.3, // Base brightness
        color: Math.random() < 0.1 ? (Math.random() < 0.5 ? '#ffccaa' : '#aaccff') : '#ffffff' // Rare colored stars
      });
    }
    
    // Initialize particles array for explosions
    this.particles = [];
  }
  
  setupEventListeners() {
    // Keyboard events
    window.addEventListener('keydown', (e) => {
      // Handle initial entry when entering high score
      if (this.showInitialEntry) {
        this.handleInitialEntry(e);
        e.preventDefault();
        return;
      }
      
      // Handle restart when game is over
      if (this.showGameOverScreen && e.code === 'Space') {
        this.restart();
        e.preventDefault();
        return;
      }
      
      // Toggle debug mode with 'D' key
      if (e.code === 'KeyD' && !this.showInitialEntry && !this.showGameOverScreen) {
        this.debugMode = !this.debugMode;
        console.log('Debug mode:', this.debugMode ? 'ON' : 'OFF');
        e.preventDefault();
        return;
      }
      
      this.keys[e.code] = true;
      // Prevent default behavior for game control keys
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'KeyW', 'KeyA', 'KeyS'].includes(e.code)) {
        e.preventDefault();
      }
    });
    
    window.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
    });
    
    // Canvas click to focus (prevents page scrolling)
    this.canvas.addEventListener('click', () => {
      this.canvas.focus();
    });
    
    // Make canvas focusable
    this.canvas.setAttribute('tabindex', '0');
    
    // Touch Controls Setup
    this.setupTouchControls();
    
    // Initialize high score display
    setTimeout(() => this.updateHighScoreDisplay(), 100);
  }
  
  startGame() {
    console.log('Starting Electric Crust Pizza Delivery game...');
    this.resumeAudio(); // Enable audio on user interaction
    
    // Test audio on game start
    setTimeout(() => {
      console.log('Testing audio with startup sound...');
      this.playTone(440, 0.2, 'sine'); // Play A note for 0.2 seconds
    }, 100);
    
    this.startBackgroundMusic(); // Start ambient music
    this.gameRunning = true;
    this.gameLoop();
  }
  
  update() {
    // Calculate delta time for accurate timers
    const now = performance.now();
    const deltaTime = this.lastUpdateTime ? (now - this.lastUpdateTime) / 1000 : 1/60;
    this.lastUpdateTime = now;
    
    // Update active power-up timers FIRST (even when paused/game over)
    console.log(`🔄 UPDATE: Power-ups active: ${this.activePowerUps.size}, deltaTime: ${deltaTime.toFixed(3)}s`);
    for (const [powerType, data] of this.activePowerUps.entries()) {
      const oldRemaining = data.remaining;
      data.remaining -= deltaTime; // Use actual time instead of frame assumption
      
      console.log(`⏰ TICK: ${powerType} - ${data.remaining.toFixed(2)}s remaining (was ${oldRemaining.toFixed(2)}s, delta: ${deltaTime.toFixed(3)}s)`);
      
      // Debug: Show timer countdown every second
      if (Math.floor(oldRemaining) !== Math.floor(data.remaining)) {
        console.log(`⏰ COUNTDOWN: ${powerType} has ${Math.ceil(data.remaining)} seconds remaining`);
      }
      
      if (data.remaining <= 0) {
        console.log(`⏰ TIMER: ${powerType} expired (${data.remaining.toFixed(2)}s remaining)`);
        this.deactivatePowerUp(powerType);
      }
    }
    
    if (this.paused || this.showGameOverScreen) {
      // Game is paused or over - no updates except for initial entry
      if (this.showInitialEntry) {
        this.handleInitialEntryTouch(); // Allow touch controls for initial entry
      }
      return;
    }
    
    if (this.showInitialEntry) {
      this.handleInitialEntryTouch(); // Handle touch input for initials
      return;
    }
    
    // Player movement
    this.player.moving = false;
    if ((this.keys['ArrowUp'] || this.keys['KeyW']) && this.player.y > 0) {
      this.player.y -= this.player.speed;
      this.player.moving = true;
    }
    if ((this.keys['ArrowDown'] || this.keys['KeyS']) && this.player.y < this.canvas.height - this.player.height) {
      this.player.y += this.player.speed;
      this.player.moving = true;
    }
    if ((this.keys['ArrowLeft'] || this.keys['KeyA']) && this.player.x > 0) {
      this.player.x -= this.player.speed;
      this.player.moving = true;
    }
    if ((this.keys['ArrowRight'] || this.keys['KeyD']) && this.player.x < this.canvas.width - this.player.width) {
      this.player.x += this.player.speed;
      this.player.moving = true;
    }
    
    // Shooting
    if (this.keys['Space']) {
      this.shoot();
    }
    
    // Update game speed based on level
    this.speed = 2 + (this.level * 0.5);
    
    // Spawn enemies with increasing difficulty
    const enemyChance = Math.min(0.02 + (this.level * 0.005), 0.04);
    if (Math.random() < enemyChance) {
      this.spawnEnemy();
    }
    
    // Spawn pizzas
    if (Math.random() < 0.015) {
      this.spawnPizza();
    }
    
    // Spawn power-ups
    if (Math.random() < 0.008) {
      this.spawnPowerup();
    }
    
    // Update all game objects
    this.updateBullets();
    this.updateEnemies();
    this.updatePizzas();
    this.updatePowerups();
    this.updateParticles();
    this.updateScorePopups();
    this.updateSoundEffects();
    this.updateStars();
    
    // Check collisions
    this.checkCollisions();
    
    // Level progression - only level up once per 10-enemy milestone
    const currentMilestone = Math.floor(this.enemiesDestroyed / 10) * 10;
    const isAtMilestone = this.enemiesDestroyed > 0 && this.enemiesDestroyed % 10 === 0;
    const hasNotCompletedThisMilestone = !this.completedMilestones.has(currentMilestone);
    
    // Debug logging for level-up tracking
    if (isAtMilestone) {
      console.log(`🔍 LEVEL CHECK: enemiesDestroyed=${this.enemiesDestroyed}, milestone=${currentMilestone}, completed=${this.completedMilestones.has(currentMilestone)}`);
    }
    
    if (isAtMilestone && hasNotCompletedThisMilestone) {
      console.log(`✅ TRIGGERING LEVEL UP: milestone=${currentMilestone}, enemiesDestroyed=${this.enemiesDestroyed}`);
      this.completedMilestones.add(currentMilestone); // Mark this milestone as completed
      console.log(`📝 MARKED milestone ${currentMilestone} as completed. Completed milestones:`, Array.from(this.completedMilestones));
      this.levelUp();
    }
  }
  
  shoot() {
    const now = Date.now();
    
    // Determine shooting rate based on power-ups
    let shootingDelay = 200; // Default 200ms
    if (this.activePowerUps.has('rapid-fire')) {
      shootingDelay = 80; // Much faster shooting
    }
    
    if (!this.lastShot || now - this.lastShot > shootingDelay) {
      // Resume audio on user interaction
      this.resumeAudio();
      
      // Multi-shot power-up creates multiple bullets
      if (this.activePowerUps.has('multi-shot')) {
        // Create 3 bullets in a spread pattern
        for (let i = -1; i <= 1; i++) {
          this.bullets.push({
            x: this.player.x + this.player.width,
            y: this.player.y + this.player.height / 2 + (i * 25),
            width: 32,
            height: 32,
            speed: 8
          });
        }
        this.playLaserSound(); // Multi-shot sound
        this.addSoundEffect(this.player.x + this.player.width, this.player.y + this.player.height / 2, 'MULTI-PEW!', '#ff6600');
      } else {
        // Standard single bullet
        this.bullets.push({
          x: this.player.x + this.player.width,
          y: this.player.y + this.player.height / 2,
          width: 32,
          height: 32,
          speed: 8
        });
        this.playLaserSound(); // Single shot sound
        this.addSoundEffect(this.player.x + this.player.width, this.player.y + this.player.height / 2, 'PEW!', '#ffff00');
      }
      
      this.lastShot = now;
    }
  }
  
  spawnEnemy() {
    // Don't spawn enemies during speed-boost power-up (hyper boost mode)
    if (this.activePowerUps.has('speed-boost')) {
      console.log('🚀 BONUS RUN: No enemies spawning during speed-boost!');
      return;
    }
    
    // Don't spawn enemies during level-up celebration
    if (this.activePowerUps.has('level-celebration')) {
      console.log('🎉 LEVEL UP: No enemies spawning during level-up celebration!');
      return;
    }
    
    const enemyTypes = [
      { name: 'invader', size: 40, health: 1, speed: 1, color: '#8b0000' },
      { name: 'ufo', size: 45, health: 2, speed: 1.5, color: '#c0392b' },
      { name: 'scout', size: 35, health: 1, speed: 2.5, color: '#8b0000' },
      { name: 'tank', size: 50, health: 3, speed: 0.8, color: '#8b0000' }
    ];
    
    const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
    this.enemies.push({
      ...enemyType,
      x: this.canvas.width,
      y: Math.random() * (this.canvas.height - enemyType.size - 40) + 20,
      width: enemyType.size,
      height: enemyType.size,
      maxHealth: enemyType.health
    });
  }
  
  spawnPizza() {
    this.pizzas.push({
      x: this.canvas.width,
      y: Math.random() * (this.canvas.height - 60) + 30,
      width: 60,
      height: 60,
      rotation: 0
    });
  }
  
  spawnPowerup() {
    const powerupTypes = [
      { type: 'rapid-fire', weight: 25, color: '#ff6600', icon: '⚡' },
      { type: 'multi-shot', weight: 20, color: '#ff0066', icon: '💥' },
      { type: 'shield', weight: 20, color: '#0066ff', icon: '🛡️' },
      { type: 'speed-boost', weight: 15, color: '#00ff66', icon: '🚀' },
      { type: 'health', weight: 15, color: '#ff3333', icon: '❤️' },
      { type: 'score-bonus', weight: 5, color: '#ffdd00', icon: '⭐' }
    ];
    
    // Weighted random selection
    const totalWeight = powerupTypes.reduce((sum, p) => sum + p.weight, 0);
    let random = Math.random() * totalWeight;
    let selectedType = powerupTypes[0];
    
    for (const powerupType of powerupTypes) {
      if (random < powerupType.weight) {
        selectedType = powerupType;
        break;
      }
      random -= powerupType.weight;
    }
    
    this.powerups.push({
      type: selectedType.type,
      color: selectedType.color,
      icon: selectedType.icon,
      x: this.canvas.width,
      y: Math.random() * (this.canvas.height - 60) + 30,
      width: 45,
      height: 45,
      rotation: 0,
      pulseScale: 1,
      glowIntensity: 0
    });
  }
  
  updateBullets() {
    this.bullets = this.bullets.filter(bullet => {
      bullet.x += bullet.speed;
      return bullet.x < this.canvas.width + bullet.width;
    });
  }
  
  updateEnemies() {
    this.enemies = this.enemies.filter(enemy => {
      enemy.x -= this.speed * enemy.speed;
      return enemy.x + enemy.width > -50;
    });
  }
  
  updatePizzas() {
    this.pizzas = this.pizzas.filter(pizza => {
      pizza.x -= this.speed;
      pizza.rotation += 0.1;
      return pizza.x + pizza.width > -50;
    });
  }
  
  updatePowerups() {
    this.powerups = this.powerups.filter(powerup => {
      powerup.x -= this.speed;
      powerup.rotation += 0.08;
      
      // Enhanced visual effects
      powerup.pulseScale = 1 + Math.sin(Date.now() * 0.006) * 0.15;
      powerup.glowIntensity = 0.5 + Math.sin(Date.now() * 0.008) * 0.3;
      
      return powerup.x + powerup.width > -50;
    });
    
  }
  
  updateParticles() {
    this.particles = this.particles.filter(particle => {
      particle.x += particle.vx;
      particle.y += particle.vy;
      particle.vx *= 0.98; // Air resistance
      particle.vy *= 0.98;
      particle.life--;
      particle.alpha = particle.life / particle.maxLife;
      return particle.life > 0;
    });
    
    // Update screen shake
    if (this.screenShake > 0) {
      this.screenShake *= 0.6;
      if (this.screenShake < 0.1) {
        this.screenShake = 0;
      }
    }
  }
  
  updateSoundEffects() {
    this.soundEffects = this.soundEffects.filter(effect => {
      effect.life--;
      effect.y -= 1;
      effect.alpha = effect.life / effect.maxLife;
      return effect.life > 0;
    });
  }
  
  updateStars() {
    this.stars.forEach(star => {
      // Hyper Boost mode: stars move MUCH faster and create streaks
      const speed = this.hyperBoostMode ? star.speed * 12 : star.speed;
      star.x -= speed;
      
      if (star.x < -5) {
        star.x = this.canvas.width + 5;
        star.y = Math.random() * this.canvas.height;
      }
    });
  }
  
  checkCollisions() {
    // Bullets vs Enemies
    for (let i = this.bullets.length - 1; i >= 0; i--) {
      const bullet = this.bullets[i];
      for (let j = this.enemies.length - 1; j >= 0; j--) {
        const enemy = this.enemies[j];
        if (this.detectCollision(bullet, enemy, "tight")) {
          this.bullets.splice(i, 1);
          enemy.health--;
          
          // Add collision sparks
          this.createSparks(bullet.x + bullet.width/2, bullet.y + bullet.height/2, Math.PI, 3);
          
          if (enemy.health <= 0) {
            this.enemies.splice(j, 1);
            this.score += 10;
            this.enemiesDestroyed++;
            this.addExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
            this.addSoundEffect(enemy.x, enemy.y, 'BOOM!', '#ff4444');
            this.addScorePopup(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 10, '#ffdd00');
            this.playExplosionSound();
            // this.triggerHapticFeedback('medium'); // Enemy destroyed feedback - DISABLED
          }
          break;
        }
      }
    }
    
    // Player vs Enemies
    this.enemies.forEach((enemy, index) => {
      if (this.detectCollision(this.player, enemy, "precise")) {
        // Shield protects player from damage
        if (this.activePowerUps.has('shield')) {
          this.enemies.splice(index, 1);
          this.addSoundEffect(this.player.x, this.player.y, 'SHIELD!', '#0066ff');
          this.addExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
          this.addScorePopup(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 5, '#0066ff');
        } else {
          this.player.health--;
          this.enemies.splice(index, 1);
          this.addSoundEffect(this.player.x, this.player.y, 'OUCH!', '#ff0000');
          this.playHitSound();
          // this.triggerHapticFeedback('heavy'); // Strong feedback for taking damage - DISABLED
          
          if (this.player.health <= 0) {
            this.gameOver();
          }
        }
      }
    });
    
    // Player vs Pizzas
    this.pizzas.forEach((pizza, index) => {
      if (this.detectCollision(this.player, pizza, "circle")) {
        this.pizzas.splice(index, 1);
        this.score += 20;
        this.addSoundEffect(pizza.x, pizza.y, 'YUM!', '#ffa500');
        this.addPickupEffect(pizza.x + pizza.width/2, pizza.y + pizza.height/2);
        this.addScorePopup(pizza.x + pizza.width/2, pizza.y + pizza.height/2, 20, '#ff8800');
        this.playPizzaPickupSound();
      }
    });
    
    // Player vs Power-ups
    this.powerups.forEach((powerup, index) => {
      if (this.detectCollision(this.player, powerup, "circle")) {
        this.powerups.splice(index, 1);
        this.handlePowerup(powerup);
        this.addSoundEffect(powerup.x, powerup.y, 'POWER!', powerup.color);
        this.addPowerUpPickupEffect(powerup);
      }
    });
  }
  
  checkCollision(rect1, rect2, margin = 0) {
    // Positive margin = stricter collision (smaller collision box)
    // Negative margin = looser collision (larger collision box)
    return !(rect1.x + margin >= rect2.x + rect2.width - margin ||
             rect2.x + margin >= rect1.x + rect1.width - margin ||
             rect1.y + margin >= rect2.y + rect2.height - margin ||
             rect2.y + margin >= rect1.y + rect1.height - margin);
  }

  checkCircularCollision(obj1, obj2) {
    const centerX1 = obj1.x + obj1.width / 2;
    const centerY1 = obj1.y + obj1.height / 2;
    const centerX2 = obj2.x + obj2.width / 2;
    const centerY2 = obj2.y + obj2.height / 2;
    
    const distance = Math.sqrt(
      Math.pow(centerX2 - centerX1, 2) + Math.pow(centerY2 - centerY1, 2)
    );
    
    const combinedRadius = (obj1.width + obj1.height + obj2.width + obj2.height) / 8;
    return distance < combinedRadius;
  } 

  detectCollision(objA, objB, type = "rectangle") {
    switch (type) {
      case "circle":
        return this.checkCircularCollision(objA, objB);
      case "loose": 
        return this.checkCollision(objA, objB, -5); // 5px more generous
      case "tight":
        return this.checkCollision(objA, objB, 8); // 8px stricter for precise hits
      case "precise":
        return this.checkCollision(objA, objB, 20); // 20px stricter for very precise hits
      default:
        return this.checkCollision(objA, objB);
    }
  }
  
  handlePowerup(powerup) {
    switch (powerup.type) {
      case 'rapid-fire':
        this.activatePowerUp('rapid-fire', 8.0); // 8 seconds
        this.playPowerUpSound('rapid-fire');
        // this.triggerHapticFeedback('heavy'); // Power-up collected feedback - DISABLED
        break;
        
      case 'multi-shot':
        this.activatePowerUp('multi-shot', 10.0); // 10 seconds
        this.playPowerUpSound('multi-shot');
        // this.triggerHapticFeedback('heavy'); // Power-up collected feedback - DISABLED
        break;
        
      case 'shield':
        this.activatePowerUp('shield', 12.0); // 12 seconds
        this.playPowerUpSound('shield');
        // this.triggerHapticFeedback('heavy'); // Power-up collected feedback - DISABLED
        break;
        
      case 'speed-boost':
        this.activatePowerUp('speed-boost', 6.0); // 6 seconds
        this.playPowerUpSound('speed-boost');
        // this.triggerHapticFeedback('heavy'); // Power-up collected feedback - DISABLED
        break;
        
      case 'health':
        this.player.health = Math.min(this.player.health + 1, this.player.maxHealth);
        this.addScorePopup(this.player.x + this.player.width/2, this.player.y, '+1 HEALTH', '#ff6666');
        // this.triggerHapticFeedback('heavy'); // Health restored feedback - DISABLED
        this.playPowerUpSound('health');
        break;
        
      case 'score-bonus':
        this.score += 100;
        this.addScorePopup(this.player.x + this.player.width/2, this.player.y, 100, '#ffdd00');
        this.playPowerUpSound('bonus');
        // this.triggerHapticFeedback('heavy'); // Score bonus feedback - DISABLED
        break;
    }
  }
  
  levelUp() {
    this.level++;
    
    // Clear all enemies during level-up celebration (like bonus mode)
    this.enemies = [];
    console.log('🎉 LEVEL UP: Clearing enemies for celebration!');
    
    // Use the same power-up system for consistent timing
    this.activatePowerUp('level-celebration', 7.0); // 7 seconds like other power-ups
    
    // Only show the main level-up effect (remove duplicate sound effect text)
    this.addLevelUpEffect();
    this.playLevelUpSound();
    // Note: No health penalty for leveling up - this is a reward!
  }
  
  addExplosion(x, y) {
    // Create main explosion
    this.createExplosion(x, y, '#ff6b35', 12);
    
    // Add some sparks
    this.createSparks(x, y, 0, 8);
    
    // Add haptic feedback for explosions - DISABLED
    // this.triggerHapticFeedback('heavy');
    
    // Add screen shake effect
    this.screenShake = 3;
  }
  
  addPickupEffect(x, y) {
    const particles = ['✨', '⭐'];
    for (let i = 0; i < 5; i++) {
      this.particles.push({
        x: x,
        y: y,
        dx: (Math.random() - 0.5) * 4,
        dy: (Math.random() - 0.5) * 4,
        life: 25,
        maxLife: 25,
        particle: particles[Math.floor(Math.random() * particles.length)],
        alpha: 1
      });
    }
  }
  
  addSoundEffect(x, y, text, color) {
    this.soundEffects.push({
      x: x,
      y: y,
      text: text,
      color: color,
      life: 60,
      maxLife: 60,
      alpha: 1
    });
  }
  
  gameOver() {
    // Check if it's a high score
    console.log(`🏆 GAME OVER: Score=${this.score}`);
    console.log(`🏆 CURRENT HIGH SCORES:`, this.highScores);
    console.log(`🏆 LOWEST HIGH SCORE:`, this.highScores[this.highScores.length - 1].score);
    console.log(`🏆 IS HIGH SCORE:`, this.isHighScore(this.score));
    
    if (this.isHighScore(this.score)) {
      console.log(`🎉 NEW HIGH SCORE! Starting initial entry...`);
      this.startInitialEntry();
    } else {
      console.log(`❌ Not a high score. Showing game over screen.`);
      this.showGameOverScreen = true;
    }
    
    this.addSoundEffect(this.canvas.width/2, this.canvas.height/2, 'GAME OVER!', '#ff0000');
    this.playGameOverSound();
    this.stopBackgroundMusic(); // Stop music on game over
  }
  
  restart() {
    this.showGameOverScreen = false;
    this.showInitialEntry = false;
    this.gameOverTimer = 0;
    this.score = 0;
    this.level = 1;
    this.speed = 2;
    this.enemiesDestroyed = 0;
    this.lastLevelUpAt = 0; // Reset level-up tracker
    this.completedMilestones.clear(); // Reset completed milestones
    this.player.health = this.player.maxHealth;
    this.player.speed = 5;
    this.player.x = 80;
    this.player.y = 300;
    
    // Clear all arrays
    this.bullets = [];
    this.enemies = [];
    this.pizzas = [];
    this.powerups = [];
    this.particles = [];
    this.soundEffects = [];
    
    // Restart background music
    this.stopBackgroundMusic();
    this.startBackgroundMusic();
  }
  
  // High Score System Methods
  async loadHighScores() {
    console.log('📚 LOADING HIGH SCORES FROM JSON FILE');
    try {
      // Try to load from the repo JSON file first
      const response = await fetch('./assets/pizza-game-scores.json');
      if (response.ok) {
        const data = await response.json();
        console.log(`📚 Loaded ${data.highScores.length} high scores from JSON file:`, data.highScores);
        return data.highScores;
      } else {
        console.warn('📚 Could not load JSON file, trying localStorage...');
      }
    } catch (e) {
      console.warn('📚 Error loading JSON file:', e);
    }
    
    // Fallback to localStorage
    try {
      const saved = localStorage.getItem('pizzaGameHighScores');
      console.log('📚 Raw localStorage data:', saved);
      if (saved) {
        const parsed = JSON.parse(saved);
        console.log(`📚 Loaded ${parsed.length} high scores from localStorage:`, parsed);
        return parsed;
      }
    } catch (e) {
      console.warn('Could not load high scores from localStorage:', e);
    }
    
    console.log('📚 Using default high scores');
    // Default high scores - classic arcade style
    return [
      { initials: 'AAA', score: 5000 },
      { initials: 'BBB', score: 4500 },
      { initials: 'CCC', score: 4000 },
      { initials: 'DDD', score: 3500 },
      { initials: 'EEE', score: 3000 },
      { initials: 'FFF', score: 2500 },
      { initials: 'GGG', score: 2000 },
      { initials: 'HHH', score: 1500 },
      { initials: 'III', score: 1000 },
      { initials: 'JJJ', score: 500 }
    ];
  }
  
  saveHighScores() {
    console.log(`💾 SAVING ${this.highScores.length} HIGH SCORES TO LOCALSTORAGE (BACKUP):`, this.highScores);
    console.log('💾 localStorage available:', typeof(Storage) !== "undefined");
    console.log('💾 Mobile device:', this.isMobile());
    
    try {
      const dataToSave = JSON.stringify(this.highScores);
      console.log('💾 Data to save (length):', dataToSave.length);
      localStorage.setItem('pizzaGameHighScores', dataToSave);
      console.log('💾 BACKUP SAVE SUCCESSFUL, data length:', dataToSave.length);
      
      // Verify the save by reading it back immediately
      const verification = localStorage.getItem('pizzaGameHighScores');
      console.log('💾 VERIFICATION - Saved data exists:', verification !== null);
      console.log('💾 VERIFICATION - Saved data length:', verification ? verification.length : 0);
      
      if (verification) {
        const parsedVerification = JSON.parse(verification);
        console.log('💾 VERIFICATION - Parsed length:', parsedVerification.length);
      }
    } catch (e) {
      console.error('💾 ERROR saving high scores:', e);
      console.log('💾 localStorage quota exceeded?', e.name === 'QuotaExceededError');
    }
  }
  
  isHighScore(score) {
    // If high scores haven't loaded yet, treat as high score to be safe
    if (!this.highScores || this.highScores.length === 0) {
      console.log(`🔍 isHighScore check: No scores loaded yet, treating as high score`);
      return true;
    }
    
    const lowestScore = this.highScores[this.highScores.length - 1].score;
    const hasLessThan10 = this.highScores.length < 10;
    const beatsLowest = score > lowestScore;
    
    console.log(`🔍 isHighScore check: score=${score}, lowestScore=${lowestScore}, hasLessThan10=${hasLessThan10}, beatsLowest=${beatsLowest}`);
    
    return beatsLowest || hasLessThan10;
  }
  
  addHighScore(initials, score) {
    console.log(`📝 ADDING HIGH SCORE: ${initials} - ${score}`);
    console.log(`📝 BEFORE: High scores length = ${this.highScores.length}`, this.highScores);
    
    // Check for inappropriate initials
    const cleanInitials = this.filterProfanity(initials.toUpperCase());
    if (cleanInitials !== initials.toUpperCase()) {
      console.log(`🚫 Filtered offensive initials: ${initials} → ${cleanInitials}`);
      this.showProfanityWarning(initials, cleanInitials);
    }
    
    const newEntry = { 
      initials: cleanInitials, 
      score: score,
      date: new Date().toISOString().split('T')[0] // Add date in YYYY-MM-DD format
    };
    
    this.highScores.push(newEntry);
    this.highScores.sort((a, b) => b.score - a.score);
    this.highScores = this.highScores.slice(0, 10); // Keep only top 10
    
    console.log(`📝 AFTER: High scores length = ${this.highScores.length}`, this.highScores);
    
    // Save to localStorage as backup
    this.saveHighScores();
    
    // Automatically update the global leaderboard
    this.updateGlobalLeaderboardReliable(newEntry);
    
    console.log(`💾 HIGH SCORES SAVED TO LOCALSTORAGE`);
  }

  updateGlobalLeaderboardReliable(newEntry) {
    console.log('🌍 RECORDING NEW HIGH SCORE:', newEntry);
    
    // Show updating notification briefly for good UX
    this.showUpdatingNotification();
    
    // Create the updated high scores data
    const updatedData = {
      highScores: this.highScores,
      lastUpdated: new Date().toISOString(),
      version: "1.0"
    };
    
    // Try automatic update first, then fallback to simple success message
    this.attemptAutomaticUpdate(newEntry, updatedData);
  }

  async attemptAutomaticUpdate(newEntry, updatedData) {
    try {
      // Try to update via a serverless function or direct API call
      const success = await this.updateViaAutomatedService(updatedData);
      
      if (success) {
        this.showSimpleSuccessNotification(newEntry);
      } else {
        // Fallback to simple local success - no confusing JSON for users
        this.showLocalSuccessNotification(newEntry);
      }
    } catch (error) {
      console.log('🌍 Automatic update failed, showing local success:', error);
      this.showLocalSuccessNotification(newEntry);
    }
  }

  async updateViaAutomatedService(data) {
    try {
      // Check if GitHub token is configured
      const config = window.GITHUB_CONFIG;
      if (!config || !config.token) {
        console.log('🌍 No GitHub token configured, using local-only mode');
        return false;
      }
      
      console.log('🌍 Attempting automatic GitHub update...');
      
      // Get current file to get its SHA
      const getUrl = `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${config.path}`;
      const getResponse = await fetch(getUrl, {
        headers: {
          'Authorization': `token ${config.token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });
      
      if (!getResponse.ok) {
        console.error('🌍 Failed to get current file:', getResponse.status);
        return false;
      }
      
      const currentFile = await getResponse.json();
      
      // Prepare the update
      const content = btoa(JSON.stringify(data, null, 2)); // Base64 encode
      const commitMessage = `🏆 Auto-update: ${data.highScores[0].initials} scored ${data.highScores[0].score.toLocaleString()}!`;
      
      const updateData = {
        message: commitMessage,
        content: content,
        sha: currentFile.sha,
        branch: config.branch
      };
      
      // Update the file
      const updateResponse = await fetch(getUrl, {
        method: 'PUT',
        headers: {
          'Authorization': `token ${config.token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
      });
      
      if (updateResponse.ok) {
        console.log('🌍 ✅ Successfully updated GitHub file!');
        return true;
      } else {
        const errorText = await updateResponse.text();
        console.error('🌍 Failed to update file:', updateResponse.status, errorText);
        return false;
      }
      
    } catch (error) {
      console.error('🌍 GitHub API error:', error);
      return false;
    }
  }

  // Legacy function - keeping for now but using reliable version above

  filterProfanity(initials) {
    // List of inappropriate words/combinations to filter
    const bannedWords = [
      'ASS', 'CUM', 'TIT', 'SEX', 'XXX', 'WTF', 'FUK', 'FCK', 'SHT', 'DMN',
      'BTH', 'SLT', 'WHR', 'BTC', 'SOB', 'PIS', 'DIK', 'COK', 'BAL', 'NUT',
      'FAG', 'GAY', 'LES', 'STD', 'HIV', 'AIDS', 'KKK', 'NAZ', 'ISIS', 'KILL',
      'DIE', 'HATE', 'NAZI', 'DRUG', 'WEED', 'POT', 'COKE', 'METH', 'PORN',
      'NUDE', 'SEXY', 'MILF', 'THOT', 'SIMP', 'INCEL', 'CHAD', 'BETA'
    ];
    
    // Check if initials contain any banned words
    const cleanInitials = initials.toUpperCase();
    
    for (const banned of bannedWords) {
      if (cleanInitials.includes(banned)) {
        console.log(`🚫 Blocked inappropriate initials: ${initials} (contains: ${banned})`);
        // Replace with neutral alternatives
        return this.generateCleanInitials();
      }
    }
    
    // Additional check for letter combinations that could be offensive
    const offensivePatterns = [
      /^A+S+$/, // All A's and S's
      /^F+U+$/, // All F's and U's  
      /^D+M+N+$/, // DMN variations
      /^H+E+L+$/, // HEL variations
      /^666$/, // Devil number
      /^420$/ // Drug reference
    ];
    
    for (const pattern of offensivePatterns) {
      if (pattern.test(cleanInitials)) {
        console.log(`🚫 Blocked pattern: ${initials}`);
        return this.generateCleanInitials();
      }
    }
    
    return cleanInitials;
  }
  
  generateCleanInitials() {
    // Generate random clean 3-letter combinations
    const cleanLetters = ['A', 'B', 'C', 'D', 'E', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'R', 'T', 'V', 'W', 'Y', 'Z'];
    const cleanCombos = ['ACE', 'TOP', 'PRO', 'WIN', 'MVP', 'VIP', 'GOD', 'ONE', 'BIG', 'MAX'];
    
    // Return a random clean combo
    return cleanCombos[Math.floor(Math.random() * cleanCombos.length)];
  }
  
  showProfanityWarning(original, replacement) {
    const overlay = document.createElement('div');
    overlay.id = 'profanityWarning';
    overlay.style.cssText = `
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 10002;
      max-width: 500px;
      font-family: Arial, sans-serif;
      border: 2px solid #ffdd00;
      text-align: center;
    `;
    
    overlay.innerHTML = `
      <h3 style="color: #ffdd00; margin: 0 0 10px 0;">🚫 Inappropriate Initials Detected</h3>
      <p style="margin: 0 0 10px 0;">The initials "<strong>${original}</strong>" contain inappropriate content.</p>
      <p style="margin: 0 0 10px 0;">Your initials have been changed to: <strong style="color: #ffdd00;">${replacement}</strong></p>
      <p style="margin: 0 0 15px 0; font-size: 0.9em;">Please keep the leaderboard family-friendly! 🎮</p>
      <button onclick="this.parentElement.remove()" style="background: #ffdd00; color: #333; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">Got it!</button>
    `;
    
    document.body.appendChild(overlay);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
      if (document.getElementById('profanityWarning')) {
        overlay.remove();
      }
    }, 10000);
  }

  async updateGlobalLeaderboard(newEntry) {
    console.log('🌍 UPDATING GLOBAL LEADERBOARD:', newEntry);
    
    try {
      // Show updating notification
      this.showUpdatingNotification();
      
      // Create the updated high scores data
      const updatedData = {
        highScores: this.highScores,
        lastUpdated: new Date().toISOString(),
        version: "1.0"
      };
      
      // Use GitHub API to update the file
      const success = await this.updateGitHubFile(updatedData);
      
      if (success) {
        this.showSuccessNotification(newEntry);
        console.log('🌍 ✅ Global leaderboard updated successfully!');
      } else {
        this.showErrorNotification(newEntry);
        console.log('� ❌ Failed to update global leaderboard');
      }
      
    } catch (error) {
      console.error('🌍 Error updating global leaderboard:', error);
      this.showErrorNotification(newEntry);
    }
  }
  
  async updateGitHubFile(data) {
    try {
      // GitHub repository details
      const owner = 'charlesbwhetstone';
      const repo = 'charlesbwhetstone.github.io';
      const path = 'assets/pizza-game-scores.json';
      const branch = 'main';
      
      // First, get the current file to get its SHA
      const getResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branch}`);
      
      if (!getResponse.ok) {
        console.error('Failed to get current file:', getResponse.status);
        return false;
      }
      
      const currentFile = await getResponse.json();
      const currentSha = currentFile.sha;
      
      // Prepare the update
      const content = btoa(JSON.stringify(data, null, 2)); // Base64 encode
      const commitMessage = `Update high scores - New record: ${data.highScores[0].initials} with ${data.highScores[0].score.toLocaleString()} points!`;
      
      // Note: This would require a GitHub Personal Access Token
      // For now, we'll use a different approach - GitHub Issues API or a webhook service
      console.log('🌍 Would update with:', { commitMessage, content: data });
      
      // Alternative: Use a free service like JSONBin or create a GitHub Issue
      return await this.updateViaIssue(data);
      
    } catch (error) {
      console.error('GitHub API error:', error);
      return false;
    }
  }
  
  async updateViaIssue(data) {
    try {
      // Create a GitHub issue with the high score data
      // This doesn't require authentication and serves as a notification system
      const owner = 'charlesbwhetstone';
      const repo = 'charlesbwhetstone.github.io';
      
      const issueData = {
        title: `🏆 New High Score: ${data.highScores[0].initials} - ${data.highScores[0].score.toLocaleString()}`,
        body: `A new high score has been achieved!

**Player:** ${data.highScores[0].initials}
**Score:** ${data.highScores[0].score.toLocaleString()}
**Date:** ${data.highScores[0].date}

**Updated Leaderboard:**
${data.highScores.map((entry, index) => `${index + 1}. ${entry.initials}: ${entry.score.toLocaleString()}`).join('\n')}

**JSON Data to Update:**
\`\`\`json
${JSON.stringify(data, null, 2)}
\`\`\`

*This issue was automatically created by the Pizza Game leaderboard system.*`,
        labels: ['high-score', 'leaderboard']
      };
      
      console.log('🌍 Attempting to create GitHub issue...');
      
      const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/issues`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/vnd.github.v3+json'
        },
        body: JSON.stringify(issueData)
      });
      
      console.log('🌍 GitHub API response status:', response.status);
      
      if (response.ok) {
        const result = await response.json();
        console.log('🌍 ✅ High score issue created successfully!', result.html_url);
        return true;
      } else {
        const errorText = await response.text();
        console.error('🌍 Failed to create issue:', response.status, errorText);
        
        // Check specific error types
        if (response.status === 403) {
          console.log('🌍 Rate limited or forbidden - this is normal without auth token');
        } else if (response.status === 422) {
          console.log('🌍 Validation error - issue data might be invalid');
        }
        
        return false;
      }
      
    } catch (error) {
      console.error('🌍 Network error creating issue:', error);
      
      // Check if it's a network connectivity issue
      if (error.name === 'TypeError' && error.message.includes('fetch')) {
        console.log('🌍 Network connectivity issue detected');
      }
      
      return false;
    }
  }
  
  showUpdatingNotification() {
    const overlay = document.createElement('div');
    overlay.id = 'updatingNotification';
    overlay.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 4px 30px rgba(0,0,0,0.3);
      z-index: 10001;
      text-align: center;
      font-family: Arial, sans-serif;
      border: 2px solid #ffdd00;
    `;
    
    overlay.innerHTML = `
      <div style="font-size: 2em; margin-bottom: 10px;">🌍</div>
      <h3 style="color: #ffdd00; margin: 0 0 10px 0;">Updating Global Leaderboard...</h3>
      <div style="margin: 20px 0;">
        <div style="width: 40px; height: 40px; border: 3px solid #ffdd00; border-top: 3px solid transparent; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
      </div>
    `;
    
    // Add CSS animation
    const style = document.createElement('style');
    style.textContent = `
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    `;
    document.head.appendChild(style);
    
    document.body.appendChild(overlay);
  }
  
  showSuccessNotification(newEntry) {
    // Remove updating notification
    const updating = document.getElementById('updatingNotification');
    if (updating) updating.remove();
    
    const overlay = document.createElement('div');
    overlay.id = 'successNotification';
    overlay.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 10001;
      max-width: 400px;
      font-family: Arial, sans-serif;
      border: 2px solid #ffdd00;
    `;
    
    overlay.innerHTML = `
      <h3 style="color: #ffdd00; margin: 0 0 10px 0;">🏆 HIGH SCORE RECORDED!</h3>
      <p style="margin: 0 0 10px 0;"><strong>${newEntry.initials}: ${newEntry.score.toLocaleString()}</strong></p>
      <p style="margin: 0 0 10px 0; font-size: 0.9em;">✅ Your score has been added to the global leaderboard!</p>
      <p style="margin: 0 0 15px 0; font-size: 0.8em;">All players will see your achievement on their next game.</p>
      <button onclick="this.parentElement.remove()" style="background: #ffdd00; color: #333; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">Awesome!</button>
    `;
    
    document.body.appendChild(overlay);
    
    // Auto-remove after 15 seconds
    setTimeout(() => {
      if (document.getElementById('successNotification')) {
        overlay.remove();
      }
    }, 15000);
  }
  
  showErrorNotification(newEntry) {
    // Remove updating notification
    const updating = document.getElementById('updatingNotification');
    if (updating) updating.remove();
    
    const overlay = document.createElement('div');
    overlay.id = 'errorNotification';
    overlay.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 10001;
      max-width: 450px;
      font-family: Arial, sans-serif;
      border: 2px solid #ffdd00;
    `;
    
    overlay.innerHTML = `
      <h3 style="color: #ffdd00; margin: 0 0 10px 0;">📶 Connection Issue</h3>
      <p style="margin: 0 0 10px 0;"><strong>${newEntry.initials}: ${newEntry.score.toLocaleString()}</strong></p>
      <p style="margin: 0 0 10px 0; font-size: 0.9em;">⚠️ Couldn't connect to update the global leaderboard.</p>
      <p style="margin: 0 0 15px 0; font-size: 0.8em;">✅ Your score is saved locally and will appear when you reload!</p>
      
      <details style="margin: 10px 0; font-size: 0.8em;">
        <summary style="cursor: pointer; color: #ffdd00;">📋 Manual Update Data</summary>
        <code style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 3px; display: block; margin-top: 5px; word-break: break-all;">
          { "initials": "${newEntry.initials}", "score": ${newEntry.score}, "date": "${newEntry.date}" }
        </code>
      </details>
      
      <div style="display: flex; gap: 10px; margin-top: 15px;">
        <button onclick="this.parentElement.remove()" style="background: #ffdd00; color: #333; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; flex: 1;">Got it</button>
        <button onclick="navigator.clipboard.writeText('{ \"initials\": \"${newEntry.initials}\", \"score\": ${newEntry.score}, \"date\": \"${newEntry.date}\" }').then(() => alert('Copied to clipboard!')).catch(() => alert('Copy failed'))" style="background: #667eea; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; flex: 1;">📋 Copy</button>
      </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Auto-remove after 30 seconds instead of 20
    setTimeout(() => {
      if (document.getElementById('errorNotification')) {
        overlay.remove();
      }
    }, 30000);
  }
  
  showOfflineNotification(newEntry) {
    // Remove updating notification
    const updating = document.getElementById('updatingNotification');
    if (updating) updating.remove();
    
    const overlay = document.createElement('div');
    overlay.id = 'offlineNotification';
    overlay.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #ffa726 0%, #ff9800 100%);
      color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 10001;
      max-width: 400px;
      font-family: Arial, sans-serif;
      border: 2px solid #ffdd00;
    `;
    
    overlay.innerHTML = `
      <h3 style="color: #ffdd00; margin: 0 0 10px 0;">📶 Offline Mode</h3>
      <p style="margin: 0 0 10px 0;"><strong>${newEntry.initials}: ${newEntry.score.toLocaleString()}</strong></p>
      <p style="margin: 0 0 10px 0; font-size: 0.9em;">📱 No internet connection detected.</p>
      <p style="margin: 0 0 15px 0; font-size: 0.8em;">✅ Your score is saved locally! When you're back online, the global leaderboard will update.</p>
      <button onclick="this.parentElement.remove()" style="background: #ffdd00; color: #333; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">Got it!</button>
    `;
    
    document.body.appendChild(overlay);
    
    // Auto-remove after 15 seconds
    setTimeout(() => {
      if (document.getElementById('offlineNotification')) {
        overlay.remove();
      }
    }, 15000);
  }
  
  showManualUpdateNotification(newEntry, updatedData) {
    // Remove updating notification
    const updating = document.getElementById('updatingNotification');
    if (updating) updating.remove();
    
    const overlay = document.createElement('div');
    overlay.id = 'manualUpdateNotification';
    overlay.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 10001;
      max-width: 450px;
      font-family: Arial, sans-serif;
      border: 2px solid #ffdd00;
    `;
    
    overlay.innerHTML = `
      <h3 style="color: #ffdd00; margin: 0 0 10px 0;">🏆 NEW HIGH SCORE RECORDED!</h3>
      <p style="margin: 0 0 10px 0;"><strong>${newEntry.initials}: ${newEntry.score.toLocaleString()}</strong></p>
      <p style="margin: 0 0 10px 0; font-size: 0.9em;">✅ Your score is saved locally!</p>
      <p style="margin: 0 0 15px 0; font-size: 0.8em;">To add to the global leaderboard, copy this data:</p>
      
      <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 0.8em; word-break: break-all;">
        <div style="margin-bottom: 5px; font-weight: bold; color: #ffdd00;">Add to assets/pizza-game-scores.json:</div>
        <code>{ "initials": "${newEntry.initials}", "score": ${newEntry.score}, "date": "${newEntry.date}" }</code>
      </div>
      
      <div style="display: flex; gap: 10px; margin-top: 15px;">
        <button onclick="this.parentElement.remove()" style="background: #4caf50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; flex: 1;">Got it!</button>
        <button onclick="navigator.clipboard.writeText('{ \"initials\": \"${newEntry.initials}\", \"score\": ${newEntry.score}, \"date\": \"${newEntry.date}\" }').then(() => {this.textContent='Copied!'; setTimeout(() => this.textContent='📋 Copy', 2000)}).catch(() => this.textContent='Copy failed')" style="background: #ffdd00; color: #333; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; flex: 1;">📋 Copy</button>
      </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Auto-remove after 45 seconds
    setTimeout(() => {
      if (document.getElementById('manualUpdateNotification')) {
        overlay.remove();
      }
    }, 45000);
  }
  
  showSimpleSuccessNotification(newEntry) {
    // Remove updating notification
    const updating = document.getElementById('updatingNotification');
    if (updating) updating.remove();
    
    const overlay = document.createElement('div');
    overlay.id = 'simpleSuccessNotification';
    overlay.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 10001;
      max-width: 400px;
      font-family: Arial, sans-serif;
      border: 2px solid #ffdd00;
    `;
    
    overlay.innerHTML = `
      <h3 style="color: #ffdd00; margin: 0 0 10px 0;">🏆 HIGH SCORE ACHIEVED!</h3>
      <p style="margin: 0 0 10px 0;"><strong>${newEntry.initials}: ${newEntry.score.toLocaleString()}</strong></p>
      <p style="margin: 0 0 15px 0; font-size: 0.9em;">🌍 Your score has been added to the global leaderboard!</p>
      <p style="margin: 0 0 15px 0; font-size: 0.8em;">All players will see your achievement on their next visit.</p>
      <button onclick="this.parentElement.remove()" style="background: #ffdd00; color: #333; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">Awesome!</button>
    `;
    
    document.body.appendChild(overlay);
    
    setTimeout(() => {
      if (document.getElementById('simpleSuccessNotification')) {
        overlay.remove();
      }
    }, 10000);
  }
  
  showLocalSuccessNotification(newEntry) {
    // Remove updating notification
    const updating = document.getElementById('updatingNotification');
    if (updating) updating.remove();
    
    const overlay = document.createElement('div');
    overlay.id = 'localSuccessNotification';
    overlay.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 10001;
      max-width: 400px;
      font-family: Arial, sans-serif;
      border: 2px solid #ffdd00;
    `;
    
    overlay.innerHTML = `
      <h3 style="color: #ffdd00; margin: 0 0 10px 0;">🏆 HIGH SCORE ACHIEVED!</h3>
      <p style="margin: 0 0 10px 0;"><strong>${newEntry.initials}: ${newEntry.score.toLocaleString()}</strong></p>
      <p style="margin: 0 0 10px 0; font-size: 0.9em;">✅ Your score is saved and appears on the leaderboard!</p>
      <p style="margin: 0 0 15px 0; font-size: 0.8em;">Great job! Keep playing to beat your record.</p>
      <button onclick="this.parentElement.remove()" style="background: #ffdd00; color: #333; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">Nice!</button>
    `;
    
    document.body.appendChild(overlay);
    
    setTimeout(() => {
      if (document.getElementById('localSuccessNotification')) {
        overlay.remove();
      }
    }, 8000);
  }

  startInitialEntry() {
    console.log('🎯 Starting high score initial entry');
    console.log('🎯 Is mobile device:', this.isMobile());
    console.log('🎯 Current score:', this.score);
    this.showInitialEntry = true;
    this.showGameOverScreen = false; // Make sure game over screen doesn't override
    this.initialEntry = { initials: 'AAA', currentChar: 0 };
    
    // For mobile devices, create an HTML overlay as backup
    if (this.isMobile()) {
      console.log('🎯 Creating mobile overlay for initial entry');
      this.createMobileInitialEntryOverlay();
    } else {
      console.log('🎯 Using desktop canvas initial entry');
    }
  }
  
  handleInitialEntry(e) {
    const allowedKeys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*+-=?';
    
    if (e.code === 'Enter' || e.code === 'Space') {
      // Submit initials
      console.log('🖥️ DESKTOP SUBMIT - Adding high score');
      console.log('🖥️ Initials:', this.initialEntry.initials);
      console.log('🖥️ Score:', this.score);
      this.addHighScore(this.initialEntry.initials, this.score);
      this.showInitialEntry = false;
      this.showGameOverScreen = true; // Return to game over screen
    } else if (e.code === 'ArrowLeft' && this.initialEntry.currentChar > 0) {
      this.initialEntry.currentChar--;
    } else if (e.code === 'ArrowRight' && this.initialEntry.currentChar < 2) {
      this.initialEntry.currentChar++;
    } else if (e.code === 'ArrowUp') {
      // Cycle character up
      const currentChar = this.initialEntry.initials[this.initialEntry.currentChar];
      const currentIndex = allowedKeys.indexOf(currentChar);
      const newIndex = (currentIndex + 1) % allowedKeys.length;
      this.initialEntry.initials = this.initialEntry.initials.substring(0, this.initialEntry.currentChar) + 
                                  allowedKeys[newIndex] + 
                                  this.initialEntry.initials.substring(this.initialEntry.currentChar + 1);
    } else if (e.code === 'ArrowDown') {
      // Cycle character down
      const currentChar = this.initialEntry.initials[this.initialEntry.currentChar];
      const currentIndex = allowedKeys.indexOf(currentChar);
      const newIndex = (currentIndex - 1 + allowedKeys.length) % allowedKeys.length;
      this.initialEntry.initials = this.initialEntry.initials.substring(0, this.initialEntry.currentChar) + 
                                  allowedKeys[newIndex] + 
                                  this.initialEntry.initials.substring(this.initialEntry.currentChar + 1);
    } else if (e.key.length === 1 && allowedKeys.includes(e.key.toUpperCase())) {
      // Direct letter input
      this.initialEntry.initials = this.initialEntry.initials.substring(0, this.initialEntry.currentChar) + 
                                  e.key.toUpperCase() + 
                                  this.initialEntry.initials.substring(this.initialEntry.currentChar + 1);
      if (this.initialEntry.currentChar < 2) {
        this.initialEntry.currentChar++;
      }
    }
  }
  
  // Handle touch input for initial entry
  handleInitialEntryTouch() {
    if (!this.showInitialEntry) return;
    
    const allowedKeys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    
    // Map touch controls to initial entry controls
    if (this.keys['ArrowLeft'] && this.initialEntry.currentChar > 0) {
      this.initialEntry.currentChar--;
      this.keys['ArrowLeft'] = false; // Prevent repeat
    }
    if (this.keys['ArrowRight'] && this.initialEntry.currentChar < 2) {
      this.initialEntry.currentChar++;
      this.keys['ArrowRight'] = false; // Prevent repeat
    }
    if (this.keys['ArrowUp']) {
      // Cycle character up
      const currentChar = this.initialEntry.initials[this.initialEntry.currentChar];
      const currentIndex = allowedKeys.indexOf(currentChar);
      const newIndex = (currentIndex + 1) % allowedKeys.length;
      this.initialEntry.initials = this.initialEntry.initials.substring(0, this.initialEntry.currentChar) + 
                                  allowedKeys[newIndex] + 
                                  this.initialEntry.initials.substring(this.initialEntry.currentChar + 1);
      this.keys['ArrowUp'] = false; // Prevent repeat
    }
    if (this.keys['ArrowDown']) {
      // Cycle character down
      const currentChar = this.initialEntry.initials[this.initialEntry.currentChar];
      const currentIndex = allowedKeys.indexOf(currentChar);
      const newIndex = (currentIndex - 1 + allowedKeys.length) % allowedKeys.length;
      this.initialEntry.initials = this.initialEntry.initials.substring(0, this.initialEntry.currentChar) + 
                                  allowedKeys[newIndex] + 
                                  this.initialEntry.initials.substring(this.initialEntry.currentChar + 1);
      this.keys['ArrowDown'] = false; // Prevent repeat
    }
    if (this.keys['Space']) {
      // Submit initials
      console.log('📱 TOUCH SUBMIT - Adding high score');
      console.log('📱 Initials:', this.initialEntry.initials);
      console.log('📱 Score:', this.score);
      this.addHighScore(this.initialEntry.initials, this.score);
      this.showInitialEntry = false;
      this.showGameOverScreen = true;
      this.keys['Space'] = false; // Prevent repeat
    }
  }
  
  togglePause() {
    if (!this.showGameOverScreen) {
      this.paused = !this.paused;
    }
  }
  
  // Initialize Audio System
  initAudioSystem() {
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.masterGain = this.audioContext.createGain();
      this.masterGain.connect(this.audioContext.destination);
      this.masterGain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
      this.audioEnabled = true;
      console.log('Audio system initialized successfully, state:', this.audioContext.state);
    } catch (error) {
      console.warn('Audio not supported:', error);
      this.audioEnabled = false;
    }
  }

  resumeAudio() {
    if (this.audioContext && this.audioContext.state === 'suspended') {
      console.log('Resuming audio context...');
      this.audioContext.resume().then(() => {
        console.log('Audio context resumed successfully');
      });
    }
  }

  playExplosionSound() {
    if (!this.audioEnabled) return;
    this.resumeAudio();
    // Simple beep for explosion
    this.playTone(150, 0.3, 'square');
  }

  playPizzaPickupSound() {
    if (!this.audioEnabled) return;
    this.resumeAudio();
    this.playTone(600, 0.2, 'sine');
  }

  playLaserSound() {
    if (!this.audioEnabled) return;
    this.resumeAudio();
    this.playTone(800, 0.1, 'sawtooth');
  }

  playTone(frequency, duration, type = 'sine') {
    if (!this.audioEnabled || !this.audioContext) {
      console.log('Audio not enabled or context missing');
      return;
    }
    
    try {
      const now = this.audioContext.currentTime;
      const osc = this.audioContext.createOscillator();
      const gain = this.audioContext.createGain();
      
      osc.type = type;
      osc.frequency.setValueAtTime(frequency, now);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
      
      osc.connect(gain);
      gain.connect(this.masterGain);
      osc.start(now);
      osc.stop(now + duration);
      
      console.log(`Playing tone: ${frequency}Hz for ${duration}s`);
    } catch (error) {
      console.error('Error playing tone:', error);
    }
  }

  startBackgroundMusic() {
    // Placeholder for background music
  }

  stopBackgroundMusic() {
    // Placeholder for stopping background music
  }

  playLevelUpSound() {
    if (!this.audioEnabled) return;
    this.playTone(500, 0.3);
  }

  playGameOverSound() {
    if (!this.audioEnabled) return;
    this.playTone(200, 1.0, 'square');
  }

  playHitSound() {
    if (!this.audioEnabled) return;
    this.playTone(100, 0.2, 'square');
  }

  playPowerUpSound(type) {
    if (!this.audioEnabled) return;
    this.playTone(1000, 0.3);
  }

  // Particle system
  createExplosion(x, y, color = '#ff6b35', particleCount = 8) {
    for (let i = 0; i < particleCount; i++) {
      const angle = (i / particleCount) * Math.PI * 2;
      const speed = Math.random() * 4 + 2;
      this.particles.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: Math.random() * 4 + 2,
        color: color,
        alpha: 1,
        life: 30 + Math.random() * 20,
        maxLife: 30 + Math.random() * 20
      });
    }
  }

  createSparks(x, y, direction = 0, sparkCount = 5) {
    for (let i = 0; i < sparkCount; i++) {
      const angle = direction + (Math.random() - 0.5) * Math.PI * 0.5;
      const speed = Math.random() * 3 + 1;
      this.particles.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: Math.random() * 2 + 1,
        color: '#ffff00',
        alpha: 1,
        life: 15 + Math.random() * 10,
        maxLife: 15 + Math.random() * 10
      });
    }
  }

  // Power-up system
  activatePowerUp(type, duration) {
    this.activePowerUps.set(type, {
      remaining: duration,
      maxDuration: duration
    });
    console.log(`⚡ POWER-UP: ${type} activated for ${duration} seconds`);
    this.applyPowerUpEffect(type);
    
    // Clear existing enemies only for speed-boost (hyper boost mode)
    if (type === 'speed-boost') {
      this.enemies = [];
      this.addSoundEffect(this.canvas.width/2, this.canvas.height/3, 'HYPER BOOST!', '#ffdd00');
    }
  }
  
  deactivatePowerUp(type) {
    console.log(`⚡ POWER-UP: ${type} deactivated/expired`);
    this.activePowerUps.delete(type);
    this.removePowerUpEffect(type);
  }
  
  applyPowerUpEffect(type) {
    switch (type) {
      case 'speed-boost':
        this.player.speed = Math.min(this.player.speed + 3, 10);
        break;
      case 'level-celebration':
        // Give HYPER BOOST during level-up celebration
        this.player.speed = Math.min(this.player.speed + 8, 18); // Super fast!
        this.hyperBoostMode = true;
        
        // Eliminate all enemies with force field effect
        this.enemies.forEach(enemy => {
          this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#00ffff', 8);
          this.addScorePopup(enemy.x + enemy.width/2, enemy.y, 'ELIMINATED!', '#00ffff');
        });
        this.enemies = []; // Clear all enemies
        
        console.log('🚀 HYPER BOOST MODE: Activated! All enemies eliminated by force field!');
        break;
    }
  }
  
  removePowerUpEffect(type) {
    switch (type) {
      case 'speed-boost':
        this.player.speed = Math.max(this.player.speed - 3, 5);
        break;
      case 'level-celebration':
        // Restore normal speed after hyper boost mode
        this.player.speed = Math.max(this.player.speed - 8, 5);
        this.hyperBoostMode = false;
        console.log('🎉 HYPER BOOST MODE: Deactivated, speed restored to', this.player.speed);
        break;
    }
  }

  addPowerUpPickupEffect(powerup) {
    this.createExplosion(powerup.x + powerup.width/2, powerup.y + powerup.height/2, powerup.color, 6);
    this.addScorePopup(powerup.x + powerup.width/2, powerup.y, powerup.icon + ' POWER-UP!', powerup.color);
  }

  isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
           window.innerWidth <= 768;
  }

  createMobileInitialEntryOverlay() {
    // Remove existing overlay if any
    const existingOverlay = document.getElementById('mobileHighScoreOverlay');
    if (existingOverlay) {
      existingOverlay.remove();
    }
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.id = 'mobileHighScoreOverlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    `;
    
    overlay.innerHTML = `
      <h1 style="color: #ffdd00; font-size: 2em; margin-bottom: 10px;">🏆 NEW HIGH SCORE! 🏆</h1>
      <p style="color: #ff6b6b; font-size: 1.5em; margin-bottom: 20px;">Score: ${this.score}</p>
      <p style="margin-bottom: 20px;">Enter your initials:</p>
      <div id="mobileInitialsDisplay" style="font-size: 2em; font-weight: bold; margin-bottom: 20px; letter-spacing: 0.2em;">AAA</div>
      <div style="display: flex; gap: 10px; margin-bottom: 20px;">
        <button id="mobilePrevChar" style="background: #667eea; color: white; border: none; padding: 15px 20px; border-radius: 5px; font-size: 1.2em;">◀</button>
        <button id="mobileNextChar" style="background: #667eea; color: white; border: none; padding: 15px 20px; border-radius: 5px; font-size: 1.2em;">▶</button>
      </div>
      <div style="display: flex; gap: 10px;">
        <button id="mobilePrevLetter" style="background: #764ba2; color: white; border: none; padding: 10px 15px; border-radius: 5px;">▲</button>
        <button id="mobileNextLetter" style="background: #764ba2; color: white; border: none; padding: 10px 15px; border-radius: 5px;">▼</button>
      </div>
      <button id="mobileSubmit" style="background: #4caf50; color: white; border: none; padding: 15px 30px; border-radius: 5px; font-size: 1.2em; margin-top: 30px;">SUBMIT</button>
    `;
    
    document.body.appendChild(overlay);
    this.setupMobileInitialEntryEvents();
  }

  setupMobileInitialEntryEvents() {
    const display = document.getElementById('mobileInitialsDisplay');
    const prevChar = document.getElementById('mobilePrevChar');
    const nextChar = document.getElementById('mobileNextChar');
    const prevLetter = document.getElementById('mobilePrevLetter');
    const nextLetter = document.getElementById('mobileNextLetter');
    const submit = document.getElementById('mobileSubmit');
    
    const updateDisplay = () => {
      const initials = this.initialEntry.initials.split('');
      let displayText = '';
      for (let i = 0; i < 3; i++) {
        if (i === this.initialEntry.currentChar) {
          displayText += `<span style="background: #ffdd00; color: black; padding: 2px 4px;">${initials[i]}</span>`;
        } else {
          displayText += initials[i];
        }
      }
      display.innerHTML = displayText;
    };
    
    prevChar.onclick = () => {
      if (this.initialEntry.currentChar > 0) {
        this.initialEntry.currentChar--;
        updateDisplay();
      }
    };
    
    nextChar.onclick = () => {
      if (this.initialEntry.currentChar < 2) {
        this.initialEntry.currentChar++;
        updateDisplay();
      }
    };
    
    prevLetter.onclick = () => {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      const initials = this.initialEntry.initials.split('');
      const currentIndex = chars.indexOf(initials[this.initialEntry.currentChar]);
      const newIndex = currentIndex > 0 ? currentIndex - 1 : chars.length - 1;
      initials[this.initialEntry.currentChar] = chars[newIndex];
      this.initialEntry.initials = initials.join('');
      updateDisplay();
    };
    
    nextLetter.onclick = () => {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      const initials = this.initialEntry.initials.split('');
      const currentIndex = chars.indexOf(initials[this.initialEntry.currentChar]);
      const newIndex = currentIndex < chars.length - 1 ? currentIndex + 1 : 0;
      initials[this.initialEntry.currentChar] = chars[newIndex];
      this.initialEntry.initials = initials.join('');
      updateDisplay();
    };
    
    submit.onclick = () => {
      console.log('📱 MOBILE SUBMIT CLICKED - Adding high score');
      console.log('📱 Initials:', this.initialEntry.initials);
      console.log('📱 Score:', this.score);
      this.addHighScore(this.initialEntry.initials, this.score);
      this.showInitialEntry = false;
      this.showGameOverScreen = true;
      document.getElementById('mobileHighScoreOverlay').remove();
      console.log('📱 Calling updateHighScoreDisplay from mobile submit');
      this.updateHighScoreDisplay();
    };
    
    updateDisplay();
  }

  // Score popup system
  addScorePopup(x, y, points, color = '#ffdd00') {
    this.scorePopups.push({
      x: x,
      y: y,
      points: points,
      color: color,
      alpha: 1,
      scale: 1,
      velocity: { x: Math.random() * 2 - 1, y: -2 },
      life: 60
    });
  }
  
  updateScorePopups() {
    this.scorePopups = this.scorePopups.filter(popup => {
      popup.x += popup.velocity.x;
      popup.y += popup.velocity.y;
      popup.velocity.y += 0.1;
      popup.alpha -= 0.016;
      popup.scale += 0.02;
      popup.life--;
      
      return popup.life > 0 && popup.alpha > 0;
    });
  }

  addLevelUpEffect() {
    this.levelUpEffect = {
      scale: 0.5,
      alpha: 1,
      life: 180, // Visual effect for ~3 seconds
      color: '#00ff88'
    };
    console.log('🎉 LEVEL UP: Starting enemy-free celebration period (7 seconds)');
  }

  // Haptic feedback for mobile
  triggerHapticFeedback(type = 'light') {
    // Completely disable haptic feedback to prevent console errors
    return;
    
    if (!navigator.vibrate) return;
    
    // Check if user has actually touched the screen
    if (!this.userHasTouched) return;
    
    const patterns = {
      light: 10,
      medium: 30,
      heavy: 50
    };
    
    const pattern = patterns[type] || patterns.light;
    try {
      navigator.vibrate(pattern);
    } catch (e) {
      // Silently fail if vibrate is blocked
    }
  }

  // Touch controls setup
  setupTouchControls() {
    const isMobile = ('ontouchstart' in window) || 
                    (navigator.maxTouchPoints > 0) || 
                    /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    this.isMobileDevice = isMobile;
    
    console.log('Mobile device detected:', isMobile);
    
    // Force show mobile controls on all mobile devices
    if (isMobile) {
      const mobileControls = document.getElementById('mobileControls');
      if (mobileControls) {
        mobileControls.style.display = 'block';
        mobileControls.style.visibility = 'visible';
        mobileControls.style.opacity = '1';
        console.log('Mobile controls enabled');
        this.initTouchControls();
      } else {
        console.log('Mobile controls element not found');
      }
    }
  }
  
  initTouchControls() {
    if (!this.keys) {
      this.keys = {};
    }
    
    this.touchState = {
      joystickActive: false,
      autoFire: false,
      autoFireInterval: null
    };
    
    const joystick = document.getElementById('virtualJoystick');
    const joystickKnob = document.getElementById('joystickKnob');
    const fireButton = document.getElementById('fireButton');
    const autoFireButton = document.getElementById('autoFireButton');
    
    if (!joystick || !joystickKnob || !fireButton || !autoFireButton) {
      return;
    }
    
    // Joystick controls
    joystick.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.touchState.joystickActive = true;
    });
    
    joystick.addEventListener('touchmove', (e) => {
      e.preventDefault();
      
      if (!this.touchState.joystickActive || !e.touches[0]) return;
      
      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      let deltaX = touch.clientX - centerX;
      let deltaY = touch.clientY - centerY;
      
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const maxDistance = 35;
      
      if (distance > maxDistance) {
        deltaX = (deltaX / distance) * maxDistance;
        deltaY = (deltaY / distance) * maxDistance;
      }
      
      joystickKnob.style.left = `calc(50% + ${deltaX}px)`;
      joystickKnob.style.top = `calc(50% + ${deltaY}px)`;
      
      // Clear movement keys
      this.keys['ArrowLeft'] = false;
      this.keys['ArrowRight'] = false;
      this.keys['ArrowUp'] = false;
      this.keys['ArrowDown'] = false;
      
      const threshold = 8;
      if (Math.abs(deltaX) > threshold) {
        if (deltaX < 0) {
          this.keys['ArrowLeft'] = true;
        } else {
          this.keys['ArrowRight'] = true;
        }
      }
      
      if (Math.abs(deltaY) > threshold) {
        if (deltaY < 0) {
          this.keys['ArrowUp'] = true;
        } else {
          this.keys['ArrowDown'] = true;
        }
      }
    });
    
    joystick.addEventListener('touchend', (e) => {
      e.preventDefault();
      this.touchState.joystickActive = false;
      
      joystickKnob.style.left = '50%';
      joystickKnob.style.top = '50%';
      
      this.keys['ArrowLeft'] = false;
      this.keys['ArrowRight'] = false;
      this.keys['ArrowUp'] = false;
      this.keys['ArrowDown'] = false;
    });
    
    // Fire button
    fireButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.keys['Space'] = true;
    });
    
    fireButton.addEventListener('touchend', (e) => {
      e.preventDefault();
      this.keys['Space'] = false;
    });
    
    // Auto-fire button
    autoFireButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.touchState.autoFire = !this.touchState.autoFire;
      
      if (this.touchState.autoFire) {
        autoFireButton.innerHTML = 'ON';
        this.touchState.autoFireInterval = setInterval(() => {
          this.keys['Space'] = true;
          setTimeout(() => {
            this.keys['Space'] = false;
          }, 50);
        }, 150);
      } else {
        autoFireButton.innerHTML = 'AUTO';
        if (this.touchState.autoFireInterval) {
          clearInterval(this.touchState.autoFireInterval);
          this.touchState.autoFireInterval = null;
        }
      }
    });
  }
  
  // Main drawing function
  draw() {
    this.ctx.save();
    if (this.screenShake > 0) {
      const shakeX = (Math.random() - 0.5) * this.screenShake;
      const shakeY = (Math.random() - 0.5) * this.screenShake;
      this.ctx.translate(shakeX, shakeY);
    }
    
    // Space background
    const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
    gradient.addColorStop(0, '#0a0a1f');
    gradient.addColorStop(0.3, '#1a1a3f');
    gradient.addColorStop(0.6, '#2d1a4a');
    gradient.addColorStop(1, '#3a2d5a');
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Draw stars
    this.stars.forEach(star => {
      star.twinkle += 0.03;
      const twinkleBrightness = star.brightness + Math.sin(star.twinkle) * 0.3;
      const alpha = Math.max(0.1, Math.min(1, twinkleBrightness));
      
      if (this.hyperBoostMode) {
        // Hyper boost streaks!
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
        this.ctx.lineWidth = star.size * 0.5;
        this.ctx.beginPath();
        this.ctx.moveTo(star.x, star.y);
        this.ctx.lineTo(star.x + 40, star.y); // Create horizontal streak
        this.ctx.stroke();
        
        // Bright center point
        this.ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        this.ctx.fillRect(star.x, star.y, star.size * 1.5, star.size * 1.5);
      } else {
        // Normal twinkling stars
        this.ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        this.ctx.fillRect(star.x, star.y, star.size, star.size);
      }
    });
    
    // Draw particles
    this.drawParticles();
    
    // Draw player (rocket)
    this.drawPlayer();
    
    // Draw bullets
    this.drawBullets();
    
    // Draw enemies
    this.drawEnemies();
    
    // Draw pizzas
    this.drawPizzas();
    
    // Draw power-ups
    this.drawPowerups();
    
    // Draw sound effects
    this.drawSoundEffects();
    
    // Draw UI
    this.drawUI();
    
    // Draw score popups
    this.drawScorePopups();
    
    // Draw level up effect
    this.drawLevelUpEffect();
    
    // Game over screen
    if (this.showGameOverScreen) {
      this.drawGameOverScreen();
    }
    
    // Initial entry screen
    if (this.showInitialEntry) {
      this.drawInitialEntryScreen();
    }
    
    // Pause screen
    if (this.paused && !this.showGameOverScreen && !this.showInitialEntry) {
      this.drawPauseScreen();
    }
    
    // Debug collision visualization (toggle with 'D' key)
    if (this.debugMode) {
      this.drawCollisionBoxes();
    }
    
    this.ctx.restore();
  }
  
  drawPlayer() {
    this.ctx.save();
    this.ctx.translate(this.player.x + this.player.width/2, this.player.y + this.player.height/2);
    
    const floatOffset = Math.sin(Date.now() * 0.003) * 2;
    this.ctx.translate(0, floatOffset);
    
    // Hyper boost force field effect
    if (this.hyperBoostMode) {
      const time = Date.now() * 0.01;
      this.ctx.strokeStyle = `rgba(0, 255, 255, ${0.6 + Math.sin(time) * 0.3})`;
      this.ctx.lineWidth = 3;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, 60 + Math.sin(time * 1.5) * 8, 0, Math.PI * 2);
      this.ctx.stroke();
      
      // Inner energy field
      this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 + Math.sin(time * 2) * 0.2})`;
      this.ctx.lineWidth = 2;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, 45 + Math.sin(time * 2) * 5, 0, Math.PI * 2);
      this.ctx.stroke();
    }
    
    // Main body
    this.ctx.fillStyle = '#c0c0c0';
    this.ctx.fillRect(-40, -25, 75, 50);
    
    // Cockpit
    this.ctx.fillStyle = 'rgba(100, 150, 255, 0.7)';
    this.ctx.fillRect(-15, -15, 25, 30);
    
    // Nose cone
    this.ctx.fillStyle = '#ffd700';
    this.ctx.beginPath();
    this.ctx.moveTo(45, 0);
    this.ctx.lineTo(10, -18);
    this.ctx.lineTo(10, 18);
    this.ctx.closePath();
    this.ctx.fill();
    
    // Fins
    this.ctx.fillStyle = '#2c3e50';
    this.ctx.fillRect(-45, -35, 18, 22);
    this.ctx.fillRect(-45, 13, 18, 22);
    
    // Engine flames
    if (this.player.moving || Math.random() < 0.3) {
      this.ctx.fillStyle = '#ff6b35';
      this.ctx.fillRect(-65, -10, 20, 20);
      this.ctx.fillStyle = '#ffff00';
      this.ctx.fillRect(-60, -6, 15, 12);
    }
    
    // Shield effect
    if (this.activePowerUps.has('shield')) {
      const shieldPulse = 0.7 + Math.sin(Date.now() * 0.008) * 0.3;
      this.ctx.strokeStyle = '#0066ff';
      this.ctx.lineWidth = 4;
      this.ctx.globalAlpha = shieldPulse;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, 55, 0, Math.PI * 2);
      this.ctx.stroke();
      this.ctx.globalAlpha = 1;
    }
    
    this.ctx.restore();
  }
  
  drawBullets() {
    this.bullets.forEach(bullet => {
      this.ctx.save();
      this.ctx.translate(bullet.x + bullet.width/2, bullet.y + bullet.height/2);
      
      // Create laser energy blast effect
      const time = Date.now() * 0.01;
      const pulse = Math.sin(time * 3 + bullet.x * 0.1) * 0.3 + 1; // Pulsing effect
      
      // Outer glow
      this.ctx.shadowColor = '#00ffff';
      this.ctx.shadowBlur = 15 * pulse;
      this.ctx.globalAlpha = 0.8;
      
      // Main laser core (bright cyan)
      this.ctx.fillStyle = '#00ffff';
      this.ctx.beginPath();
      this.ctx.ellipse(0, 0, bullet.width/2, bullet.height/2, 0, 0, Math.PI * 2);
      this.ctx.fill();
      
      // Inner bright core (white hot center)
      this.ctx.fillStyle = '#ffffff';
      this.ctx.globalAlpha = 0.9;
      this.ctx.beginPath();
      this.ctx.ellipse(0, 0, bullet.width/3, bullet.height/3, 0, 0, Math.PI * 2);
      this.ctx.fill();
      
      // Energy trail streaks
      this.ctx.globalAlpha = 0.6;
      this.ctx.strokeStyle = '#00cccc';
      this.ctx.lineWidth = 2;
      this.ctx.lineCap = 'round';
      
      // Create dynamic trail lines
      for (let i = 0; i < 3; i++) {
        const offset = Math.sin(time * 2 + i) * 3;
        this.ctx.beginPath();
        this.ctx.moveTo(-bullet.width/2 - 8, offset);
        this.ctx.lineTo(-bullet.width/2 - 15, offset * 1.5);
        this.ctx.stroke();
      }
      
      // Electric spark effect
      this.ctx.globalAlpha = 0.7;
      this.ctx.fillStyle = '#88ffff';
      for (let i = 0; i < 4; i++) {
        const sparkAngle = (time * 5 + i * Math.PI/2) % (Math.PI * 2);
        const sparkDist = bullet.width/2 + 2;
        const sparkX = Math.cos(sparkAngle) * sparkDist;
        const sparkY = Math.sin(sparkAngle) * sparkDist;
        this.ctx.beginPath();
        this.ctx.arc(sparkX, sparkY, 1, 0, Math.PI * 2);
        this.ctx.fill();
      }
      
      this.ctx.shadowBlur = 0;
      this.ctx.globalAlpha = 1;
      this.ctx.restore();
    });
  }
  
  drawEnemies() {
    this.enemies.forEach(enemy => {
      this.ctx.save();
      this.ctx.translate(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
      
      const size = enemy.width / 2;
      
      if (enemy.name === 'ufo') {
        // UFO design
        this.ctx.fillStyle = '#a0a0a0';
        this.ctx.beginPath();
        this.ctx.ellipse(0, 5, size * 0.9, size * 0.4, 0, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.fillStyle = 'rgba(100, 150, 255, 0.6)';
        this.ctx.beginPath();
        this.ctx.ellipse(0, -5, size * 0.6, size * 0.6, 0, 0, Math.PI);
        this.ctx.fill();
      } else {
        // Standard enemy
        this.ctx.fillStyle = enemy.color;
        this.ctx.fillRect(-size * 0.8, -size * 0.6, size * 1.6, size * 1.2);
        
        this.ctx.fillStyle = '#ffff00';
        this.ctx.beginPath();
        this.ctx.arc(0, -size * 0.2, size * 0.3, 0, Math.PI * 2);
        this.ctx.fill();
      }
      
      this.ctx.restore();
      
      // Health bar
      if (enemy.maxHealth > 1) {
        const healthPercent = enemy.health / enemy.maxHealth;
        this.ctx.fillStyle = '#333';
        this.ctx.fillRect(enemy.x, enemy.y - 12, enemy.width, 6);
        
        this.ctx.fillStyle = healthPercent > 0.6 ? '#00ff00' : 
                            healthPercent > 0.3 ? '#ffff00' : '#ff0000';
        this.ctx.fillRect(enemy.x, enemy.y - 12, healthPercent * enemy.width, 6);
      }
    });
  }
  
  drawPizzas() {
    this.pizzas.forEach(pizza => {
      this.ctx.save();
      this.ctx.translate(pizza.x + pizza.width/2, pizza.y + pizza.height/2);
      this.ctx.rotate(pizza.rotation);
      
      const radius = pizza.width/2;
      
      // Simple pizza base (crust + cheese in one)
      this.ctx.fillStyle = '#ffcc66';
      this.ctx.shadowColor = '#ff8c00';
      this.ctx.shadowBlur = 6;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
      this.ctx.fill();
      
      // Simple pepperoni slices (no complex calculations)
      this.ctx.fillStyle = '#cc3333';
      this.ctx.shadowBlur = 0;
      
      // Traditional pepperoni distribution across the whole pizza
      const pepperoniSpots = [
        // Center area
        [0, 0],
        // Inner ring - expanded for better coverage
        [-radius * 0.25, -radius * 0.25],
        [radius * 0.25, -radius * 0.25],
        [radius * 0.3, 0],
        [radius * 0.25, radius * 0.25],
        [-radius * 0.25, radius * 0.25],
        [-radius * 0.3, 0],
        // Outer ring - key positions for balance
        [0, -radius * 0.55],
        [radius * 0.5, radius * 0.4],
        [-radius * 0.5, radius * 0.4]
      ];
      
      // Draw simple pepperoni circles
      pepperoniSpots.forEach(pos => {
        this.ctx.beginPath();
        this.ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);
        this.ctx.fill();
      });
      
      this.ctx.shadowBlur = 0;
      this.ctx.restore();
    });
  }
  
  drawPowerups() {
    this.powerups.forEach(powerup => {
      this.ctx.save();
      this.ctx.translate(powerup.x + powerup.width/2, powerup.y + powerup.height/2);
      this.ctx.rotate(powerup.rotation);
      
      this.ctx.scale(powerup.pulseScale, powerup.pulseScale);
      this.ctx.shadowColor = powerup.color;
      this.ctx.shadowBlur = 15 * powerup.glowIntensity;
      
      this.ctx.fillStyle = powerup.color;
      this.ctx.globalAlpha = 0.3 * powerup.glowIntensity;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, 25, 0, Math.PI * 2);
      this.ctx.fill();
      
      this.ctx.globalAlpha = 1;
      this.ctx.font = '24px Arial';
      this.ctx.textAlign = 'center';
      this.ctx.textBaseline = 'middle';
      this.ctx.fillStyle = '#ffffff';
      this.ctx.fillText(powerup.icon, 0, 0);
      
      this.ctx.shadowBlur = 0;
      this.ctx.restore();
    });
  }
  
  drawParticles() {
    this.particles.forEach(particle => {
      this.ctx.save();
      this.ctx.globalAlpha = particle.alpha;
      this.ctx.fillStyle = particle.color;
      this.ctx.shadowColor = particle.color;
      this.ctx.shadowBlur = particle.size * 2;
      this.ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
      this.ctx.restore();
    });
  }
  
  drawSoundEffects() {
    this.soundEffects.forEach(effect => {
      this.ctx.globalAlpha = effect.alpha;
      this.ctx.fillStyle = effect.color;
      this.ctx.font = 'bold 16px Arial';
      this.ctx.fillText(effect.text, effect.x, effect.y);
    });
    this.ctx.globalAlpha = 1;
  }
  
  drawCollisionBoxes() {
    // Debug mode: Draw collision boxes for all objects
    this.ctx.save();
    this.ctx.lineWidth = 2;
    
    // Player collision box (green) - with precise collision detection margins
    this.ctx.strokeStyle = '#00ff00';
    const playerMargin = 20; // Same margin as enemies for precise detection
    this.ctx.strokeRect(
      this.player.x + playerMargin, 
      this.player.y + playerMargin, 
      this.player.width - (playerMargin * 2), 
      this.player.height - (playerMargin * 2)
    );
    
    // Show original player boundary with dashed line
    this.ctx.setLineDash([5, 5]);
    this.ctx.strokeStyle = '#66ff66';
    this.ctx.strokeRect(this.player.x, this.player.y, this.player.width, this.player.height);
    this.ctx.setLineDash([]);
    this.ctx.strokeStyle = '#00ff00';
    
    // Enemy collision boxes (red) - with precise collision detection margins
    this.ctx.strokeStyle = '#ff0000';
    this.enemies.forEach(enemy => {
      // Show the actual collision box used for precise detection (20px stricter)
      const margin = 20; // This shrinks the collision box significantly
      this.ctx.strokeRect(
        enemy.x + margin, 
        enemy.y + margin, 
        enemy.width - (margin * 2), 
        enemy.height - (margin * 2)
      );
      
      // Show original object boundary with dashed line
      this.ctx.setLineDash([5, 5]);
      this.ctx.strokeStyle = '#ff6666';
      this.ctx.strokeRect(enemy.x, enemy.y, enemy.width, enemy.height);
      this.ctx.setLineDash([]);
      this.ctx.strokeStyle = '#ff0000';
    });
    
    // Pizza collision boxes (orange)
    this.ctx.strokeStyle = '#ffa500';
    this.pizzas.forEach(pizza => {
      this.ctx.strokeRect(pizza.x, pizza.y, pizza.width, pizza.height);
    });
    
    // Power-up collision boxes (yellow)
    this.ctx.strokeStyle = '#ffff00';
    this.powerups.forEach(powerup => {
      this.ctx.strokeRect(powerup.x, powerup.y, powerup.width, powerup.height);
    });
    
    // Bullet collision boxes (cyan)
    this.ctx.strokeStyle = '#00ffff';
    this.bullets.forEach(bullet => {
      this.ctx.strokeRect(bullet.x, bullet.y, bullet.width, bullet.height);
    });
    
    // Debug info text
    this.ctx.fillStyle = '#ffffff';
    this.ctx.font = 'bold 14px Arial';
    this.ctx.fillText('DEBUG MODE (Press D to toggle)', 10, this.canvas.height - 30);
    this.ctx.fillText('Green=Player, Red=Enemies (solid=collision 20px tight, dashed=visual)', 10, this.canvas.height - 10);
    
    this.ctx.restore();
  }
  
  drawUI() {
    // Health bar
    const healthBarWidth = 220;
    const healthBarHeight = 35;
    
    this.ctx.fillStyle = '#2a2a2a';
    this.ctx.fillRect(20, 20, healthBarWidth, healthBarHeight);
    
    const healthPercentage = this.player.health / this.player.maxHealth;
    this.ctx.fillStyle = healthPercentage > 0.6 ? '#00ff88' : 
                        healthPercentage > 0.3 ? '#ffdd00' : '#ff4444';
    this.ctx.fillRect(20, 20, healthBarWidth * healthPercentage, healthBarHeight);
    
    this.ctx.strokeStyle = '#ffffff';
    this.ctx.lineWidth = 3;
    this.ctx.strokeRect(20, 20, healthBarWidth, healthBarHeight);
    
    this.ctx.fillStyle = '#fff';
    this.ctx.font = 'bold 18px Arial';
    this.ctx.fillText(`Health: ${this.player.health}/${this.player.maxHealth}`, 28, 42);
    
    // Score
    this.ctx.fillStyle = '#ffdd00';
    this.ctx.font = 'bold 28px Arial';
    this.ctx.fillText(`Score: ${this.score}`, 20, 85);
    
    // Level
    this.ctx.fillStyle = '#00ddff';
    this.ctx.font = 'bold 24px Arial';
    this.ctx.fillText(`Level: ${this.level}`, 20, 115);
    
    // Enemies destroyed
    this.ctx.fillStyle = '#ff6666';
    this.ctx.font = 'bold 20px Arial';
    this.ctx.fillText(`Destroyed: ${this.enemiesDestroyed}`, 20, 145);
    
    // Active power-ups
    if (this.activePowerUps.size > 0) {
      let powerUpX = 20;
      const powerUpY = 175;
      
      this.ctx.font = 'bold 14px Arial';
      this.ctx.fillStyle = '#ffffff';
      this.ctx.fillText('Active Powers:', powerUpX, powerUpY);
      
      powerUpX += 110;
      
      // Check if in bonus mode
      const inBonusMode = this.activePowerUps.has('speed-boost');
      
      if (inBonusMode) {
        this.ctx.font = 'bold 16px Arial';
        this.ctx.fillStyle = '#ffdd00';
        this.ctx.fillText('🚀 HYPER BOOST - NO ENEMIES! 🚀', 20, 195);
      }
      
      for (const [powerType, data] of this.activePowerUps.entries()) {
        const timeLeft = Math.ceil(data.remaining);
        this.ctx.fillStyle = powerType === 'speed-boost' ? '#ffdd00' : '#00ddff';
        this.ctx.font = 'bold 14px Arial';
        this.ctx.fillText(`${powerType}: ${timeLeft}s`, powerUpX, powerUpY);
        powerUpX += 150;
      }
    }
  }
  
  drawScorePopups() {
    this.scorePopups.forEach(popup => {
      this.ctx.save();
      this.ctx.globalAlpha = popup.alpha;
      this.ctx.font = `bold ${18 * popup.scale}px Arial`;
      this.ctx.fillStyle = popup.color;
      this.ctx.strokeStyle = '#000';
      this.ctx.lineWidth = 2;
      this.ctx.textAlign = 'center';
      
      this.ctx.shadowColor = popup.color;
      this.ctx.shadowBlur = 10 * popup.alpha;
      
      this.ctx.strokeText(`+${popup.points}`, popup.x, popup.y);
      this.ctx.fillText(`+${popup.points}`, popup.x, popup.y);
      
      this.ctx.restore();
    });
    this.ctx.textAlign = 'left';
  }
  
  drawLevelUpEffect() {
    if (!this.levelUpEffect) return;
    
    const effect = this.levelUpEffect;
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    
    this.ctx.save();
    this.ctx.globalAlpha = effect.alpha;
    this.ctx.textAlign = 'center';
    
    const pulseScale = effect.scale + Math.sin(Date.now() * 0.02) * 0.1;
    this.ctx.font = `bold ${48 * pulseScale}px Arial`;
    
    this.ctx.fillStyle = effect.color;
    this.ctx.strokeStyle = '#003366';
    this.ctx.lineWidth = 3;
    
    this.ctx.shadowColor = effect.color;
    this.ctx.shadowBlur = 20;
    
    this.ctx.strokeText('WARP MODE!', centerX, centerY - 50);
    this.ctx.fillText('WARP MODE!', centerX, centerY - 50);
    
    this.ctx.restore();
    
    effect.scale += 0.003; // Slower scale growth for visual effect
    effect.alpha -= 0.005; // Fade over ~3 seconds
    effect.life--;
    
    if (effect.life <= 0 || effect.alpha <= 0) {
      this.levelUpEffect = null;
    }
  }
  
  drawGameOverScreen() {
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    
    this.ctx.fillStyle = '#ff0000';
    this.ctx.font = 'bold 68px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.strokeStyle = '#000';
    this.ctx.lineWidth = 5;
    this.ctx.strokeText('GAME OVER!', centerX, centerY - 50);
    this.ctx.fillText('GAME OVER!', centerX, centerY - 50);
    
    this.ctx.font = 'bold 32px Arial';
    this.ctx.fillStyle = '#ffdd00';
    this.ctx.strokeText(`Final Score: ${this.score}`, centerX, centerY);
    this.ctx.fillText(`Final Score: ${this.score}`, centerX, centerY);
    
    this.ctx.strokeText(`Level Reached: ${this.level}`, centerX, centerY + 40);
    this.ctx.fillText(`Level Reached: ${this.level}`, centerX, centerY + 40);
    
    this.ctx.font = 'bold 24px Arial';
    this.ctx.fillStyle = '#00ff88';
    this.ctx.strokeText(`Press SPACE or click 🔄 Restart to play again`, centerX, centerY + 80);
    this.ctx.fillText(`Press SPACE or click 🔄 Restart to play again`, centerX, centerY + 80);
    
    this.ctx.textAlign = 'left';
  }
  
  drawInitialEntryScreen() {
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    
    this.ctx.font = 'bold 48px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.fillStyle = '#ffdd00';
    this.ctx.strokeStyle = '#000';
    this.ctx.lineWidth = 3;
    this.ctx.strokeText('🏆 NEW HIGH SCORE! 🏆', centerX, centerY - 100);
    this.ctx.fillText('🏆 NEW HIGH SCORE! 🏆', centerX, centerY - 100);
    
    this.ctx.font = 'bold 32px Arial';
    this.ctx.fillStyle = '#ff6b6b';
    this.ctx.strokeText(`Score: ${this.score}`, centerX, centerY - 50);
    this.ctx.fillText(`Score: ${this.score}`, centerX, centerY - 50);
    
    this.ctx.font = 'bold 24px Arial';
    this.ctx.fillStyle = '#00ff88';
    this.ctx.strokeText('Enter Your Initials:', centerX, centerY - 10);
    this.ctx.fillText('Enter Your Initials:', centerX, centerY - 10);
    
    // Draw initial input boxes
    const boxWidth = 60;
    const boxHeight = 60;
    const spacing = 20;
    const startX = centerX - (boxWidth * 1.5 + spacing);
    
    for (let i = 0; i < 3; i++) {
      const x = startX + (boxWidth + spacing) * i;
      const y = centerY + 20;
      
      if (i === this.initialEntry.currentChar) {
        this.ctx.fillStyle = 'rgba(255, 221, 0, 0.3)';
        this.ctx.strokeStyle = '#ffdd00';
        this.ctx.lineWidth = 3;
      } else {
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        this.ctx.strokeStyle = '#00ff88';
        this.ctx.lineWidth = 2;
      }
      
      this.ctx.fillRect(x, y, boxWidth, boxHeight);
      this.ctx.strokeRect(x, y, boxWidth, boxHeight);
      
      this.ctx.font = 'bold 40px Arial';
      this.ctx.fillStyle = i === this.initialEntry.currentChar ? '#ffdd00' : '#00ff88';
      this.ctx.textAlign = 'center';
      this.ctx.fillText(this.initialEntry.initials[i], x + boxWidth/2, y + boxHeight/2 + 15);
    }
    
    this.ctx.font = 'bold 18px Arial';
    this.ctx.fillStyle = '#ecf0f1';
    this.ctx.textAlign = 'center';
    
    if (this.isMobileDevice) {
      this.ctx.fillText('Use Joystick to Navigate  •  Fire Button to Submit', centerX, centerY + 120);
    } else {
      this.ctx.fillText('↑↓ Change Letter  •  ←→ Move Cursor  •  ENTER Submit', centerX, centerY + 120);
    }
    
    this.ctx.textAlign = 'left';
  }
  
  drawPauseScreen() {
    this.ctx.fillStyle = 'rgba(0,0,0,0.75)';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    
    this.ctx.fillStyle = '#00ddff';
    this.ctx.font = 'bold 64px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.strokeStyle = '#003366';
    this.ctx.lineWidth = 4;
    this.ctx.strokeText('PAUSED', centerX, centerY);
    this.ctx.fillText('PAUSED', centerX, centerY);
    
    this.ctx.font = 'bold 24px Arial';
    this.ctx.fillStyle = '#ffffff';
    this.ctx.strokeStyle = '#000';
    this.ctx.lineWidth = 2;
    this.ctx.strokeText('Click Resume to continue', centerX, centerY + 60);
    this.ctx.fillText('Click Resume to continue', centerX, centerY + 60);
    
    this.ctx.textAlign = 'left';
  }
  
  updateHighScoreDisplay() {
    console.log(`🎨 UPDATING HIGH SCORE DISPLAY with ${this.highScores.length} scores`);
    const container = document.getElementById('highScoreList');
    if (!container) {
      console.warn('⚠️ highScoreList container not found!');
      return;
    }
    
    container.innerHTML = '';
    
    this.highScores.forEach((entry, index) => {
      console.log(`🏆 Displaying score ${index + 1}: ${entry.initials} - ${entry.score}`);
      const div = document.createElement('div');
      div.className = 'high-score-entry';
      
      const rank = document.createElement('span');
      rank.className = 'high-score-rank';
      rank.textContent = `${index + 1}.`;
      
      const initials = document.createElement('span');
      initials.className = 'high-score-initials';
      initials.textContent = entry.initials;
      
      const score = document.createElement('span');
      score.className = 'high-score-score';
      score.textContent = entry.score.toLocaleString();
      
      div.appendChild(rank);
      div.appendChild(initials);
      div.appendChild(score);
      
      container.appendChild(div);
    });
  }
  
  gameLoop() {
    if (this.gameRunning) {
      // Debug: Check if game loop is running during power-ups
      if (this.activePowerUps && this.activePowerUps.size > 0) {
        console.log('🎮 GAME LOOP: Running with power-ups - gameRunning:', this.gameRunning);
      }
      this.update();
      this.draw();
      requestAnimationFrame(() => this.gameLoop());
    } else {
      console.log('🛑 GAME LOOP: Stopped - gameRunning:', this.gameRunning);
    }
  }
}

// Initialize game when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded, initializing game...');
  if (document.getElementById('gameCanvas')) {
    try {
      window.electricGame = new ElectricCrustPizzaGame('gameCanvas');
      console.log('Game initialized successfully!');
    } catch (error) {
      console.error('Game initialization failed:', error);
    }
  } else {
    console.error('gameCanvas element not found!');
  }
});

// Game control functions
function toggleGamePause() {
  if (window.electricGame) {
    window.electricGame.togglePause();
    const btn = document.getElementById('pauseBtn');
    btn.textContent = window.electricGame.paused ? '▶️ Resume' : '⏸️ Pause';
  }
}

function restartGame() {
  if (window.electricGame) {
    window.electricGame.resumeAudio();
    window.electricGame.restart();
    const btn = document.getElementById('pauseBtn');
    btn.textContent = '⏸️ Pause';
  }
}

function toggleFullScreen() {
  const wrapper = document.querySelector('.game-wrapper');
  const canvas = document.getElementById('gameCanvas');
  
  if (wrapper.classList.contains('fullscreen')) {
    wrapper.classList.remove('fullscreen');
    const exitBtn = wrapper.querySelector('.fullscreen-exit');
    if (exitBtn) exitBtn.remove();
    
    canvas.style.width = '';
    canvas.style.height = '';
    
    const toggleBtn = document.querySelector('.fullscreen-toggle');
    if (toggleBtn) toggleBtn.innerHTML = '🖥️ Fullscreen';
    
  } else {
    wrapper.classList.add('fullscreen');
    
    const exitBtn = document.createElement('button');
    exitBtn.className = 'fullscreen-exit';
    exitBtn.innerHTML = '✖ Exit Fullscreen';
    exitBtn.onclick = toggleFullScreen;
    wrapper.appendChild(exitBtn);
    
    const toggleBtn = document.querySelector('.fullscreen-toggle');
    if (toggleBtn) toggleBtn.innerHTML = '📱 Exit Fullscreen';
    
    const escHandler = (e) => {
      if (e.key === 'Escape' && wrapper.classList.contains('fullscreen')) {
        toggleFullScreen();
        document.removeEventListener('keydown', escHandler);
      }
    };
    document.addEventListener('keydown', escHandler);
  }
}

// Mobile landscape high score sidebar fix
function handleOrientationChange() {
  const isMobile = window.innerWidth <= 896;
  const isLandscape = window.innerHeight < window.innerWidth;
  
  if (isMobile && isLandscape) {
    // Force hide all high score related elements
    const elements = document.querySelectorAll('.high-score-sidebar, #highScoreSection, .high-score-section, [class*="high-score"]');
    elements.forEach(el => {
      el.style.display = 'none';
      el.style.visibility = 'hidden';
      el.style.position = 'absolute';
      el.style.left = '-9999px';
      el.style.top = '-9999px';
      el.style.width = '0';
      el.style.height = '0';
      el.style.overflow = 'hidden';
      el.style.opacity = '0';
      el.style.pointerEvents = 'none';
      el.style.zIndex = '-1';
    });
    
    // Ensure game container is full width
    const gameContainer = document.querySelector('.game-container');
    if (gameContainer) {
      gameContainer.style.flexDirection = 'column';
      gameContainer.style.width = '100%';
    }
    
    const gameMain = document.querySelector('.game-main');
    if (gameMain) {
      gameMain.style.width = '100%';
      gameMain.style.maxWidth = '100%';
    }
    
    console.log('🔧 Mobile landscape: Forced high score sidebar hiding');
  }
}

// Listen for orientation changes
window.addEventListener('resize', handleOrientationChange);
window.addEventListener('orientationchange', handleOrientationChange);
document.addEventListener('DOMContentLoaded', handleOrientationChange);

// Run immediately
handleOrientationChange();

    </script>
</body>
</html>